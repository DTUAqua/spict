# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015-2016  Martin W. Pedersen, mawp@dtu.dk, wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' An S4 class to represent output from a SPiCT fit.
#' @name spictcls
#' @aliases spictcls-class
#' @exportClass spictcls
setClass("spictcls")

#' @name check.rep
#' @title Check rep list
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param reportmode0 Should it be checked that the reportmode is 0 (default: TRUE).
#' @details Internal function that checks if rep is fitted spict object.
#' @return Nothing
check.rep <- function(rep, reportmode0 = TRUE){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)){
        stop("The argument 'rep' needs to be a fitted spict object. Use 'fit.spict()' to fit a spict model!")
    }else if(reportmode0 && !rep$inp$reportmode == 0){
        stop("All states of the spict model need to be reported! Set the argument 'inp$reportmode' to 0 and fit spict
 again!")
    }
    return(TRUE)
}

#' @name make.ffacvec
#' @title Make ffac vector
#' @param inp Input list
#' @param ffac Factor to multiply current F by
#' @return Input list containing ffacvec
#' @export
make.ffacvec <- function(inp, ffac){
    if(!"ns" %in% names(inp)) stop("inp needs to be a checked input list - use 'check.inp()'!")
    inp$ffacvec <- rep(1, inp$ns)
    inp$ffac <- ffac
    # Start in indpred[2] because indpred[1] is mainly for plotting
    ind <- which(inp$time == inp$maninterval[1])
    inp$ffacvec[ind] <- ffac
    inp$ffacvec <- inp$ffacvec + 1e-8 # Add small to avoid taking log of 0
    return(inp)
}

#' @name make.fconvec
#' @title Make fcon vector
#' @param inp Input list
#' @param fcon Constant to add to F
#' @return Input list containing fconvec
#' @export
make.fconvec <- function(inp, fcon){
    if(!"ns" %in% names(inp)) stop("inp needs to be a checked input list - use 'check.inp()'!")
    inp$fconvec <- numeric(inp$ns)
    inp$fconvec[inp$indpred[-1]] <- fcon
    inp$fconvec <- inp$fconvec + 1e-8 # Add small to avoid taking log of 0
    return(inp)
}

#' @name meanvar2shaperate
#' @title Convert mean and variance to shape and rate of gamma distribution
#' @param mean Mean value.
#' @param var Variance.
#' @return Vector containing shape and rate parameters.
#' @export
meanvar2shaperate <- function(mean, var){
    vec <- c(mean^2/var, mean/var)
    names(vec) <- c('shape', 'rate')
    return(vec)
}


#' @name shaperate2meanvar
#' @title Convert shape and rate of gamma distribution to mean and variance
#' @param shape Shape parameter
#' @param rate Rate parameter (scale = 1/rate).
#' @return Vector containing mean and var parameters.
#' @export
shaperate2meanvar <- function(shape, rate){
    vec <- c(shape/rate, shape/rate^2, sqrt(shape/rate^2))
    names(vec) <- c('mean', 'var', 'sd')
    return(vec)
}


#' @name get.version
#' @title Get version of spict including git sha1 version if available.
#' @param pkg Name of package.
#' @return Package version
#' @export
get.version <- function(pkg='spict'){
    pd <- packageDescription(pkg)
    v <- paste0(pd$Package, "_v", pd$Version)
    if (is.null(pd$GithubRef)){
        return(v)
    } else {
        paste0(v , "@", pd$GithubSHA1)
    }
}


#' @name fd
#' @title Format date
#' @param d Point in time in years as decimal number.
#' @param dec Number of decimals.
#' @return Correctly formatted date.
fd <- function(d, dec=2) sprintf('%4.2f', round(d, dec)) # Format date function


#' @name pol
#' @title Fisheries data included in Polacheck et al. (1993).
#' @details Fisheries data for south Atlantic albacore, northern Namibian hake, and New Zealand rock lobster.
#' @docType data
#' @keywords datasets
#' @usage data(pol)
#' @source Polacheck et al. (1993), Canadian Journal of Fisheries and Aquatic Science, vol 50, pp. 2597-2607.
#' @examples
#' data(pol)
#' rep <- fit.spict(inp=pol$albacore)
#' rep <- fit.spict(inp=pol$hake)
#' rep <- fit.spict(inp=pol$lobster)
#' @format Data are lists containing data and initial values for estimation formatted to be used as an input to fit.spict().
NULL


#' @name test.spict
#' @title Example of a spict analysis.
#' @details Loads a data set, fits the model, calculates one-step-ahead residuals, plots the results.
#' @param dataset Specify one of the three test data sets: 'albacore', 'hake', 'lobster'. These can be accessed with the command data(pol).
#' @return A result report as given by fit.spict().
#' @examples
#' rep <- test.spict()
#' @export
test.spict <- function(dataset='albacore'){
    # Load data
    data(pol)
    inp <- pol[[dataset]]
    if (dataset=='albacore'){
        inp$ffac <- 0.8
        nopredcyears <- 3 # Number of years to predict catch
        inp$dtpredc <- 1 # Time step when predicting catch
        inp$timepredi <- tail(inp$timeC, 1) + nopredcyears
        inp$timepredc <- tail(inp$timeC, 1) + nopredcyears
        inp$phases$logn <- -1
    }
    # Fit model
    rep <- fit.spict(inp)
    # Calculate one-step-ahead residuals
    rep <- calc.osa.resid(rep)
    # Plot results
    #graphics.off()
    dev.new(width=10, height=10)
    plot(rep)
    summary(rep)
    return(rep)
}


#' @name calc.gamma
#' @title Calculate gamma from n
#' @param n Exponent of the Pella-Tomlinson surplus production equation.
#' @export
calc.gamma <- function(n) n^(n/(n-1)) / (n-1)


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.spict.
#' @details \code{get.par} is a helper function for extracting the value and uncertainty of a specific model parameter, random effect or derived quantity. \code{list.quantities} gives the names of all quantities.
#' @param parname Character string containing the name of the variable of interest.
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @param random DUMMY not used anymore. (Is the variable a random effect? TRUE/FALSE.)
#' @param fixed DUMMY not used anymore. (Is the variable a fixed effect? TRUE/FALSE.)
#' @return get.par returns a matrix with four columns containing respectively: 1) the lower 95% confidence limit; 2) the parameter estimate; 3) the upper 95% confidence limit; 4) the parameter standard deviation in the domain it was estimated (log or non-log). `list.quantities` returns a vector with the names of all estimated parameters and derived quantities.
#' @export
#' @examples
#' ## Make the south Atlantic albacore assessment
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#'
#' ## See all quantitites that can be extracted
#' list.quantities(rep)
#'
#' ## Extract the Bmsy reference point
#' Bmsy <- get.par('logBmsy', rep, exp=TRUE)
#'
#' ## Extract the exploitable biomass estimates
#' Best <- get.par('logB', rep, exp=TRUE)
#'
#' ## Extract the estimated caryting capacity
#' K <- get.par('logK', rep, exp=TRUE)
get.par <- function(parname, rep=rep, exp=FALSE, random=FALSE, fixed=FALSE){
    if (!'sderr' %in% names(rep)){
        indran <- which(names(rep$par.random)==parname)
        indfix <- which(names(rep$par.fixed)==parname)
        indsdr <- which(names(rep$value)==parname)
        indopt <- which(names(rep$opt$par)==parname)
        est <- NULL
        if (length(indran)>0){
            est <- rep$par.random[indran]
            sd <- sqrt(rep$diag.cov.random[indran])
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if (length(indfix)>0){
            est <- rep$par.fixed[indfix]
            sd <- sqrt(diag(rep$cov.fixed))[indfix]
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if (length(indsdr)>0){
            est <- rep$value[indsdr]
            sd <- rep$sd[indsdr]
            ll <- est - 1.96*sd
            ul <- est + 1.96*sd
        }
        if (length(est)==0){
            ll <- NA
            ul <- NA
            sd <- NA
            est <- NA
            if (length(indopt)>0){
                est <- rep$opt$par[indopt]
            } else {
                if ('phases' %in% names(rep$inp)){
                    if (parname %in% names(rep$inp$phases)){
                        if (rep$inp$phases[[parname]] == -1){
                            est <- rep$inp$parlist[[parname]]
                            ll <- est
                            ul <- est
                        }
                    }else {
                        if (!is.na(parname) && parname == 'P'){
                            B <- get.par('logB', rep, exp=TRUE)
                            C <- get.par('logCpred', rep, exp=TRUE)
                            ic <- rep$inp$ic
                            nc <- rep$inp$nc
                            B0 <- B[ic, 2]
                            B1 <- B[ic+nc, 2]
                            T0 <- rep$inp$time[ic]
                            T1 <- rep$inp$time[ic+nc]
                            # Get annual average
                            est <- (B1 - B0 + C[, 2]) / (T1-T0)
                        }
                    }
                } else {
                    warning('get.par WARNING: could not extract ', parname)
                }
            }
        }
        if (exp==TRUE){
            # This is the CV of a log-normally distributed random variable
            # see https://en.wikipedia.org/wiki/Log-normal_distribution
            cv <- sqrt(exp(sd^2) - 1)
            ll <- exp(ll)
            ul <- exp(ul)
            ul[ul == Inf] <- exp(705) # Put a large but finite value instead of Inf
            est <- exp(est)
        } else {
            cv <- sd/est
        }
        out <- cbind(ll, est, ul, sd, cv)
        if (parname %in% c('logB', 'logF', 'logBBmsy', 'logFFmsy')){
            rownames(out) <- rep$inp$time
        }
        return(out)
    }
}

#' @rdname get.par
#' @export
list.quantities <- function(rep) {
    with(rep,
         sort(unique(c(names(value), names(par.fixed), names(par.random))))
         )
}

#' @name get.msyvec
#' @title If multiple growth rates (r) are used (e.g. for a seasonal model), return specified reference point for all instances of r.
#' @param inp An input list as validated by check.inp().
#' @param msy Matrix containing reference point values as given by get.par().
#' @return A list containing reference point estimates with upper and lower CI bounds.
#' @export
get.msyvec <- function(inp, msy){
    vec <- rep(0, inp$ns)
    ul <- rep(0, inp$ns)
    ll <- rep(0, inp$ns)
    nr <- length(inp$ini$logr)
    for (i in 1:nr){
        vec[inp$ir==i] <- msy[i, 2]
        ul[inp$ir==i] <- msy[i, 3]
        ll[inp$ir==i] <- msy[i, 1]
    }
    return(list(msy=vec, ll=ll, ul=ul))
}


#' @name make.splinemat
#' @title Make a spline design matrix
#' @param nseasons Number of seasons
#' @param order Order of the spline
#' @param dtfine Time between points where spline is evaluated
#' @return Spline design matrix.
#' @export
make.splinemat <- function(nseasons, order, dtfine=1/100){
    if (dtfine==1){
        d <- matrix(1, 1, 1)
    } else {
        dtspl <- 1/nseasons
        knots <- seq(0, 1, by=dtspl)
        x <- seq(0, 1-dtfine, by=dtfine)
        if (order > 1){
            #require(mgcv)
            d <- mgcv::cSplineDes(x, knots, ord=order)
        } else {
            if (order < 1){
                warning('Specified spline order (', order, ') not valid!')
                order <- 1
            }
            nx <- length(x)
            nknots <- length(knots)
            d <- matrix(0, nx, nknots-1)
            for (i in 1:(nknots-1)){
                inds <- which(x >= knots[i] & x < knots[i+1])
                d[inds, i] <- 1
            }
        }
    }
    return(d)
}


#' @name get.spline
#' @title Get the values of the seasonal spline for F.
#' @param logphi Values of the phi vector.
#' @param order Order of the spline.
#' @param dtfine Time between points where spline is evaluated.
#' @return Spline values at the points between 0 and 1 with dtfine as time step.
#' @export
get.spline <- function(logphi, order, dtfine=1/100){
    logphipar <- c(0, logphi)
    nseasons <- length(logphipar)
    d <- make.splinemat(nseasons, order, dtfine)
    spline <- as.vector(d %*% logphipar)
    spline <- c(spline, spline[1])
    return(spline)
}


#' @name get.AIC
#' @title Calculate AIC from a rep list.
#' @param rep A result report as generated by running fit.spict.
#' @return AIC
#' @export
get.AIC <- function(rep){
    negloglik <- rep$opt$objective
    numpars <- length(rep$opt$par)
    AIC <- 2*numpars + 2*negloglik
    return(AIC)
}


#' @name invlogit
#' @title Inverse logit transform.
#' @param a Value to take inverse logit of.
#' @return Inverse logit.
#' @export
invlogit <- function(a) 1/(1+exp(-a))


#' @name invlogp1
#' @title Inverse log "plus one" transform
#' @details If a = log(b-1), then the inverse transform is b = 1 + exp(a). Useful for values with lower bound at 1.
#' @param a Value to take inverse logp1 of.
#' @return Inverse logp1.
#' @export
invlogp1 <- function(a) 1 + exp(a)


#' @name guess.m
#' @title Use a simple linear regression to guess m (MSY).
#' @details Equations 9.1.7 and 9.1.8 on page 284 of FAO's tropical assessment book are used to guess MSY.
#' @param inp An input list containing data.
#' @param all.return If true also return a guess on Emsy (effort at MSY) and components of the linear regression.
#' @return The guess on MSY.
#' @export
guess.m <- function(inp, all.return=FALSE){
    meancatch <- mean(unlist(inp$obsC))
    flag <- FALSE
    if ('obsI' %in% names(inp)){
        if (length(inp$obsI) > 0){
            out <- get.catchindexoverlap(inp)
            if (!is.null(out)){
                ty <- out$ty
                y <- out$y
                tz <- out$tz
                z <- out$z
                if (length(y) == length(z)){
                    flag <- TRUE
                }
            }
        }
    }
    if (flag){
        x <- y/z
        mod0 <- lm(z ~ x)
        a <- mod0$coefficients[1]
        b <- mod0$coefficients[2]
        MSY <- -0.25*a^2/b # p. 284 in FAO's book on tropical stock assessment
        if (MSY <= 0 | summary(mod0)$r.squared < 0.3){
            MSY <- meancatch
        }
        if (all.return){
            Emsy <- -0.5*a/b # p. 284 in FAO's book on tropical stock assessment
            return(list(MSY=MSY, Emsy=Emsy, a=a, b=b, x=x, y=y, z=z, mod0=mod0))
        } else {
            return(MSY)
        }
    } else {
        return(meancatch)
    }
}


#' @name get.catchindexoverlap
#' @title Find observations of catch and index that overlap
#' @param inp An input list containing data.
#' @return List containing overlapping catch (y) and index (z) observations and their time vectors.
#' @export
get.catchindexoverlap <- function(inp){
    y <- inp$obsC
    ty <- inp$timeC
    if (length(inp$obsI) > 0 & inp$nseasons == 1){
        # Get index observations
        if (class(inp$obsI)=='list'){
            z <- inp$obsI[[1]]
            tz <- inp$timeI[[1]]
        } else {
            z <- inp$obsI
            tz <- inp$timeI
        }
        # Find overlap between catch and index observations
        zinds <- na.omit(match(round(ty), round(tz)))
        z <- z[zinds]
        tz <- tz[zinds]
        yinds <- na.omit(match(round(tz), round(ty)))
        y <- y[yinds]
        ty <- ty[yinds]
        return(list(ty=ty, y=y, tz=tz, z=z))
    } else {
        return(NULL)
    }
}

#' @name calc.EBinf
#' @title Calculate E(Binfinity), i.e. the fished equilibrium.
#' @details If a seasonal pattern in F is imposed the annual average F is used for calculating the expectation. Max() is used to avoid negative values.
#' @param K The carrying capacity.
#' @param n Pella-Tomlinson exponent.
#' @param Fl Average fishing mortality of the last year.
#' @param Fmsy Fishing mortality at MSY.
#' @param sdb2 Standard deviation squared (variance) of B process.
#' @return E(Binf).
calc.EBinf <- function(K, n, Fl, Fmsy, sdb2){
    max(c(0, K*(1 - (n-1)/n * Fl/Fmsy)^(1/(n-1)) * (1 - n/2/(1 - (1-n*Fmsy + (n-1)*Fl))*sdb2)))
}


#' @name get.EBinf
#' @title Calculate E(Binfinity) the fished equilibrium.
#' @details If a seasonal pattern in F is imposed the annual average F is used for calculating the expectation.
#' @param rep A result of fit.spict.
#' @return E(Binf).
get.EBinf <- function(rep){
    K <- get.par('logK', rep, exp=TRUE)[2]
    n <- get.par('logn', rep, exp=TRUE)[2]
    sdb2 <- get.par('logsdb', rep, exp=TRUE)[2]^2
    Fmsyall <- get.par('logFmsy', rep, exp=TRUE)
    Fmsy <- tail(Fmsyall, 1)
    logFest <- get.par('logFs', rep)
    if (min(rep$inp$dtc) < 1){
        alf <- annual(rep$inp$time, logFest[, 2])
        fff <- exp(alf$annvec)
    } else {
        #fff <- exp(logFest[rep$inp$indest,2])
        fff <- exp(logFest[, 2])
    }
    Fl <- tail(unname(fff), 1)
    EBinf <- calc.EBinf(K, n, Fl, Fmsy[2], sdb2)
}


#' @name acf.signf
#' @title Check whether ACF of residuals is significant in any lags.
#' @details This corresponds to plotting the ACF using acf() and checking whether any lags has an acf value above the CI limit.
#' @param resid Vector of residuals.
#' @param lag.max Only check from lag 1 until lag.max.
#' @param return.p Return p-values of the calculated lags.
#' @return Vector of TRUE and FALSE indicating whether significant lags were present. If return.p is TRUE then p-values are returned instead.
acf.signf <- function(resid, lag.max=4, return.p=FALSE){
    calc.pval <- function(corval, acf) 2-2*pnorm(abs(corval)*sqrt(acf$n.used))
    calc.limval <- function(p, acf) qnorm((2-p)/2)/sqrt(acf$n.used)
    inds <- which(is.na(resid))
    if (length(inds)>0){
        resid <- resid[-inds]
    }
    if (length(inds) > 1){
        warning(length(inds), 'NAs in residuals! this could create problems with the calculated ACF.')
    }
    acfC <- acf(resid, plot=FALSE, lag.max=lag.max, na.action=na.pass)
    if (return.p){
        corvals <- acfC$acf[-1]
        #out <- paste(round(calc.pval(corvals, acfC), 3), collapse=', ')
        out <- calc.pval(corvals, acfC)
    } else {
        p <- 0.05
        acflim <- calc.limval(p, acfC)
        out <- abs(acfC$acf[-1]) > acflim
    }
    return(out)
}


#' @name get.osar.pvals
#' @title Check whether ACF of catch and index residuals is significant in any lags.
#' @param rep Result of fit.spict(), but requires that also residuals have been calculated using calc.osa.resic().
#' @return Vector of p-values of length equal to the number of data series.
get.osar.pvals <- function(rep){
    pvals <- numeric(rep$inp$nindex+1)
    if ('osarC' %in% names(rep)){
        pvals[1] <- round(min(acf.signf(rep$osarC$residual, return.p=TRUE)), 3)
    }
    if ('osarI' %in% names(rep)){
        ni <- length(rep$osarI)
        for (i in 1:ni){
            pvals[i+1] <- round(min(acf.signf(rep$osarI[[i]]$residual, return.p=TRUE)), 3)
        }
    }
    return(pvals)
}


#' @name get.cov
#' @title Get covariance matrix of two reported quantities not of fixed model parameters. Covariance of fixed model parameters can be found in rep$cov.fixed.
#' @param rep Result of fit.spict().
#' @param parname1 Name first parameter.
#' @param parname2 Name second parameter.
#' @param cor If TRUE correlation matrix is reported instead of covariance matrix
#' @return Covariance matrix of specified parameters.
#' @export
get.cov <- function(rep, parname1, parname2, cor=FALSE){
    inds <- match(c(parname1, parname2), names(rep$value))
    if (cor){
        return(cov2cor(rep$cov[inds, inds]))
    } else {
        return(rep$cov[inds, inds])
    }
}


#' @name calc.bmsyk
#' @title Calculates the Bmsy/K ratio
#' @param rep Result of fit.spict().
#' @return Bmsy/K
#' @export
calc.bmsyk <- function(rep){
    if(class(rep) != "spictcls" ||
       !"par.fixed" %in% names(rep)) stop("Please provide an object fitted with 'fit.spict'.")
    bmsyk <- get.par("BmsyB0", rep, exp=FALSE)[,2]
    return(bmsyk)
}



#' @name calc.om
#' @title Calculates the order of magnitude for the relative reference
#'     levels B/Bmsy and F/Fmsy
#' @param rep Result of fit.spict().
#' @details The lower, upper values and the CI range are based on the
#'     95% confidence interval (CI).
#' @return Matrix containing the order of magnitude for B/Bmsy and
#'     F/Fmsy.
#' @export
calc.om <- function(rep){
    if(class(rep) != "spictcls" ||
       !"par.fixed" %in% names(rep)) stop("Please provide an object fitted with 'fit.spict'.")
    blbmsy <- get.par("logBlBmsy", rep, exp=TRUE)
    flfmsy <- get.par("logFlFmsy", rep, exp=TRUE)
    ## 95% CI range
    bdiff <- blbmsy[,3] - blbmsy[,1]
    fdiff <- flfmsy[,3] - flfmsy[,1]
    ## order of magnitude
    omagnib <- abs(floor(log10(blbmsy[,3])) - floor(log10(blbmsy[,1])))
    omagnif <- abs(floor(log10(flfmsy[,3])) - floor(log10(flfmsy[,1])))

    res <- round(cbind(rbind(blbmsy[,1:3],flfmsy[,1:3]),c(bdiff,fdiff),c(omagnib,omagnif)),2)
    colnames(res) <- c("lower","est","upper",
                       "CI range","order magnitude")
    rownames(res) <- c("B/Bmsy","F/Fmsy")
    return(res)
}


#' @name shorten.inp
#' @title Shorten time series of input data to specified range
#' @param inp An input list containing data.
#' @param mintime Starting time. If \code{NULL} (default), keep from the start of the time series.
#' @param maxtime Ending time. If \code{NULL} (default), keep until the end of the time series.
#' @details Time is given in decimal notation (e.g. 2005.3). If both \code{start} and \code{end}
#' are \code{NULL}, \code{inp} is returned after running \code{check.inp}.
#' @author T.K. Mildenberger <t.k.mildenberger@gmail.com>
#' @return List of shortened input time series and input variables as it is returned by \code{\link{check.inp}}
#' @seealso \code{\link{check.inp}}
#' @details If code{maxtime} is not set, i.e. the first part of the time series is cut, then management settings are not changed. Otherwise default values are used (see \code{\link{check.inp}}). The \code{ir} vector, which sets up different regimes, is always overwritten.
#' @examples
#' inp <- pol$albacore
#'
#' ## Keep only years from 1973 onwards
#' shorten.inp(inp, mintime = 1973)
#'
#' ## Keep years until 1985
#' shorten.inp(inp, maxtime = 1985)
#'
#' ## Empty data set gives an error
#' shorten.inp(inp, mintime = 1910, maxtime = 1930)
#' @export
shorten.inp <- function(inp, mintime = NULL, maxtime = NULL){
    inpin <- check.inp(inp)
    if (is.null(mintime) & is.null(maxtime)) return(inpin)
    inpout <- inpin

    ## function to find closest time
    get.inds <- function(timevec, mintime, maxtime){
        mintimePot <- min(floor(timevec))
        maxtimePot <- max(ceiling(timevec))
        ## set to limits if NULL or incorrectly set
        if (is.na(mintime) || !is.numeric(mintime) || mintime < mintimePot)
            mintime <- mintimePot
        if (is.na(maxtime) || !is.numeric(maxtime) || maxtime > maxtimePot)
            maxtime <- maxtimePot
        ## indices
        inds <- which(timevec >= mintime & timevec <= maxtime)
        return(inds)
    }

    ## catch
    inds <- get.inds(inpin$timeC,mintime,maxtime)
    inpout$obsC <- inpin$obsC[inds]
    inpout$timeC <- inpin$timeC[inds]
    inpout$dtc <- inpin$dtc[inds]
    inpout$stdevfacC <- inpin$stdevfacC[inds]
    inpout$timeCpred <- inpin$timeCpred[inds]
    inpout$dtcp <- inpin$dtcp[inds]
    inpout$nobsC <- length(inpout$obsC)
    inpout$obsidC <- seq_along(inpout$obsC)

    ## index
    if(length(inpin$obsI) > 0){
        for(i in 1:length(inpin$obsI)){
            inds <- get.inds(inpin$timeI[[i]],mintime,maxtime)
            inpout$obsI[[i]] <- inpin$obsI[[i]][inds]
            inpout$timeI[[i]] <- inpin$timeI[[i]][inds]
            inpout$obsidI[[i]] <- inpin$obsidI[[i]][inds]
        }
        if(!is.null(inpin$stdevfacI)){
            for(i in 1:length(inpin$obsI)){
                inpout$stdevfacI[[i]] <- inpin$stdevfacI[[i]][inds]
            }
        }
        inpout$nobsI <- length(inpout$obsI[[1]])
    }

    ## effort
    if(length(inpin$obsE) > 0){
        inds <- get.inds(inpin$timeE,mintime,maxtime)
        inpout$obsE <- inpin$obsE[inds]
        inpout$timeE <- inpin$timeE[inds]
        inpout$stdevfacE <- inpin$stdevfacE[inds]
        inpout$dte <- inpin$dte[inds]
    }

    timeobsall <- sort(c(inpout$timeC, inpout$timeC + inpout$dtc,
                         unlist(inpout$timeI),
                         inpout$timeE, inpout$timeE + inpout$dte))
    if (length(timeobsall) == 0) stop("All yars are outside the range ", mintime, "-", maxtime)

    # Time point to predict catches until
    inpout$timepredc <- max(timeobsall)
    inpout$timepredi <- max(timeobsall)

    # This may give a problem if effort data has later time points than catches or index
    if (inpout$nobsE > 0 & sum(inpout$nobsI) > 0){
        if (max(inpout$timeE) > max(unlist(inpout$timeI), inpout$timeC)){
            stop('Effort data must overlap temporally with index or catches')
        }
    }
    if ("eulertype" %in% names(inpout)){
        if (inpout$eulertype == 'hard'){
            # Hard Euler discretisation
            if (inpout$start.in.first.data.point){
                time <- seq(min(timeobsall),
                            max(inpout$timepredi, inpout$timepredc+inpout$dtpredc),
                            by=inpout$dteuler)
            } else {
                time <- seq(floor(min(timeobsall)),
                            max(inpout$timepredi, inpout$timepredc+inpout$dtpredc),
                            by=inpout$dteuler)
            }
            inpout$time <- time
        }
        if (inpout$eulertype == 'soft'){
            # Include times of observations (including dtc)
            time <- seq(ceiling(min(timeobsall)),
                        max(inpout$timepredi, inpout$timepredc+inpout$dtpredc),
                        by=inpout$dteuler)
            inpout$time <- sort(unique(c(timeobsall, time)))
        }
        if (!inpout$eulertype %in% c('soft', 'hard'))
            stop('inp$eulertype must be either "soft" or "hard"!')
    }

    inpout$dt <- inpout$dt[inpin$time %in% inpout$time]
    inpout$ns <- length(inpout$time)

    inpout$ffacvec <- inpout$ffacvec[inpin$time %in% inpout$time]
    inpout$fconvec <- inpout$fconvec[inpin$time %in% inpout$time]
    inpout$ini$logF <- inpout$ini$logF[inpin$time %in% inpout$time]
    inpout$ini$logu <- inpout$ini$logu[,(inpin$time %in% inpout$time)]
    inpout$ini$logB <- inpout$ini$logB[inpin$time %in% inpout$time]
    inpout$ini$logmre <- inpout$ini$logmre[inpin$time %in% inpout$time]
    inpout$ini$SARvec <- inpout$ini$SARvec[inpin$time %in% inpout$time]
    inpout$MSYregime <- inpout$MSYregime[inpin$time %in% inpout$time]
    inpout$regimeIdx <- NULL
    inpout$ir <- NULL
    inpout$ini$logr <- NULL
    if (! is.null(maxime)) {
        inpout$manstart <- NULL
    }


    if("true" %in% names(inpout)){
        inpout$true$logu <- inpout$true$logu[,(inpin$time %in% inpout$time)]
        inpout$true$logmre <- inpout$true$logmre[inpin$time %in% inpout$time]
        inpout$true$SARvec <- inpout$true$SARvec[inpin$time %in% inpout$time]
        inpout$true$time <- inpout$true$time[inpin$time %in% inpout$time]
        inds <- get.inds(inpin$timeC,mintime,maxtime)
        inpout$true$C <- inpout$true$C[inds]
        inpout$true$e.c <- inpout$true$e.c[inds]
        if(length(inpin$true$E) > 0){
            inds <- get.inds(inpin$timeE,mintime,maxtime)
            inpout$true$E <- inpout$true$E[inds]
            inpout$true$e.e <- inpout$true$e.e[inds]
        }
        if(length(inpin$true$I) > 0){
            for(i in 1:length(inpout$true$I)){
                inds <- get.inds(inpin$timeI[[i]],mintime,maxtime)
                inpout$true$I[[i]] <- inpout$true$I[[i]][inds]
                inpout$true$e.i[[i]] <- inpout$true$e.i[[i]][inds]
                inpout$true$errI[[i]] <- inpout$true$errI[[i]][inds]
            }
        }
        inpout$true$B <- inpout$true$B[inpin$time %in% inpout$time]
        inpout$true$F <- inpout$true$F[inpin$time %in% inpout$time]
        inpout$true$Fs <- inpout$true$Fs[inpin$time %in% inpout$time]
        inpout$true$e.b <- inpout$true$e.b[inpin$time %in% inpout$time]
        inpout$true$e.f <- inpout$true$e.f[inpin$time %in% inpout$time]
        inpout$true$BBmsy <- inpout$true$BBmsy[inpin$time %in% inpout$time]
        inpout$true$FFmsy <- inpout$true$FFmsy[inpin$time %in% inpout$time]
        inpout$true$logBBmsy <- inpout$true$logBBmsy[inpin$time %in% inpout$time]
        inpout$true$logFFmsy <- inpout$true$logFFmsy[inpin$time %in% inpout$time]
        inpout$true$MSYvec <- inpout$true$MSYvec[inpin$time %in% inpout$time]
        inpout$true$Fmsyvec <- inpout$true$Fmsyvec[inpin$time %in% inpout$time]
    }
    return(check.inp(inpout))
}


##' @name get.no.active.priors
##' @title Get number of active priors
##' @param inp An input list containing priors (after call to check.inp and/or fit.spict)
##' @return number of active priors
##' @export
get.no.active.priors<-function(inp){
    sum(sapply(inp$priors,function(x){
        if(is.list(x)){
            prm <- do.call(rbind,x)
            return(sum(prm[,3]))
        } else {
            x[3]
        }
    }))
}

##' @name modefrac2shaperate
##' @title Convert mode and fractile to shape and rate in Gamma distribution (only for mode>0, i.e. shape >= 1)
##' @param mode x for which f(x) is at the maximum
##' @param xf x for which P(X<=x) = f
##' @param f fractile
##' @return Vector containing shape and rate parameters.
##' @export
modefrac2shaperate<-function (mode, xf, f=0.9)
{
    dev<-function(z){
        sr <- exp(z) + c(1,0)  ## we want shape >= 1, such that mode>0
        m <- (sr[1]-1)/sr[2]
        cxf <- qgamma(f,sr[1],sr[2])
        (m-mode)^2 + (xf-cxf)^2
    }
    opt <- optim(c(0,0),dev,control=list(reltol=1e-14,abstol=1e-14, maxit=1000))
    if(opt$value > 1e-13) warning("no exact solution found")
    vec <- exp(opt$par) + c(1,0)
    names(vec) <- c("shape", "rate")
    return(vec)
}



#' @name retape.spict
#' @title Retape a fitted spict model based on an updated input list
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param inp Input list with updated settings
#' @param verbose logical; print informative text (default: FALSE)
#' @param dbg Debug flag, dbg=0 no output, dbg=1 some output, dbg=2 more output
#'     (default: 0).
#' @param mancheck Logical; Should the time-dependent objects in \code{inp} be
#'     checked against the management time and correct if necessary? (Default: TRUE)
#'
#' @details This function reevaluates derived variables of a fitted spict model
#'     after updating model settings, such as the prediction horizon or fishing
#'     mortality during the predicted time period.
#'
#' @return Retaped spict model
#'
#' @export
retape.spict <- function(rep, inp, verbose = FALSE, dbg = 0, mancheck=TRUE){
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)) stop("rep needs to be a fitted spict object!")
    print("retaping ... ")  ## REMOVE:
    repin <- rep
    inpin <- check.inp(inp, verbose = verbose, mancheck=mancheck)
    ## prevent R collapse if prediction time horizon was changed without check.man.time
    vars <- c("logmcovariatein","ffacvec","fconvec","MSYregime")
              ## not testing: "ini$logF","ini$logB","ini$logmre" ## == dim(ini$logu)[1]
    check <- rep(NA,length(vars)-1)
    for(i in 1:(length(vars)-1)) check[i] <- identical(length(inpin[[vars[i]]]), length(inpin[[vars[i+1]]]))
    if(verbose && !all(check)) stop("Some vectors in the input list 'inp' do not have the same length. Run 'check.man.time'!")
    ## Make TMB data and object
    plt <- inpin$parlist
    datint <- make.datin(inpin, dbg=dbg)
    objt <- make.obj(datint, plt, inpin, phase=1)
    objt$retape()
    ## Get updated sd report
    objt$fn(repin$opt$par)
    ## get updated sd report
    verflag <- as.numeric(gsub('[.]', '', as.character(packageVersion('TMB')))) >= 171
    if(verflag){
        repout <- try(TMB::sdreport(objt,
                                    getJointPrecision=repin$inp$getJointPrecision,
                                    bias.correct=repin$inp$bias.correct,
                                    bias.correct.control=repin$inp$bias.correct.control,
                                    getReportCovariance=repin$inp$getReportCovariance),silent=TRUE)
    }else{
        repout <- try(TMB::sdreport(objt,
                                    getJointPrecision=repin$inp$getJointPrecision,
                                    bias.correct=repin$inp$bias.correct,
                                    bias.correct.control=repin$inp$bias.correct.control),silent=TRUE)
    }
    if(class(repout) == 'try-error'){
        stop("Could not calculate the sdreport of the retaped model based on provided input list.")
    }else{
        repout$inp <- inpin
        repout$obj <- objt
        repout$opt <- repin$opt
        repout$opt$gr <- repout$obj$gr(repin$opt$par)
        repout$pl <- repout$obj$env$parList(repin$opt$par)
        repout$obj$fn()
        repout$Cp <- repout$obj$report()$Cp
        repout$report <- repout$obj$report()
        if(inpin$reportall && !inpin$osar.method == 'none'){
            reposar <- try(calc.osa.resid(repout), silent=TRUE)
            if (class(reposar) != 'try-error') repout <- reposar
        }
        repout$computing.time <- repin$computing.time
        if("man" %in% names(repin)) repout$man <- repin$man
        if("manbase" %in% names(repin)) repout$manbase <- repin$manbase
        class(repout) <- "spictcls"
    }
    return(repout)
}
