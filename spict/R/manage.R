# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015-2016  Martin W. Pedersen, mawp@dtu.dk, wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#' @name manage
#' @title Calculate predictions under 8 default management scenarios
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarios Vector of integers specifying which scenarios to run or
#'     'all' to run all scenarios. Default: 'all'.
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: maninterval = c(2020.25,2021.25). Default:
#'     NULL.
#' @param maneval Time at which to evaluate model states. Example: maneval =
#'     2021.25. Default: NULL.
#' @param intermediatePeriodCatch Catch during intermediate period, e.g. last year's TAC (default:
#'     \code{NULL}; see details for more information).
#' @param intermediatePeriodCatchSDFac Factor for the multiplication of the standard deviation of the
#'     catch during the intermediate period (default: 1).
#' @param intermediatePeriodCatchList List defining catch in the intermediate
#'     period obtaining the elements 'obsC', 'timeC', and 'dtc' (optional
#'     element 'stdevfacC' which is 1 if not provided)
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @return List containing results of management calculations.
#' @references ICES. 2017. Report of the Workshop on the Development of the ICES
#'     approach to providing MSY advice for category 3 and 4 stocks
#'     (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/ACOM:47.
#'     53 pp.
#'
#' @details The 8 default scenarios are:
#'
#' \itemize{
#'   \item{"1"}{"currentCatch": Keep the catch of the current year (i.e. the last observed catch).}
#'   \item{"2"}{"currentF":  Keep the F of the current year.}
#'   \item{"3"}{"Fmsy": Fish at Fmsy i.e. F=Fmsy.}
#'   \item{"4"}{"noF": No fishing, reduce to 1\% of current F.}
#'   \item{"5"}{"redF25": Reduce F by X\%. Default X = 25.}
#'   \item{"6"}{"incrF25": Increase F by X\%. Default X = 25.}
#'   \item{"7"}{"msyHockeyStick": Use ICES MSY hockey-stick advice rule (ICES, 2017).}
#'   \item{"8"}{"ices": Use ICES MSY 35th hockey-stick advice rule (ICES, 2019).}}
#'
#' Scenario 7 implements the ICES MSY advice rule for stocks that are assessed
#' using spict (ICES 2017). MSY B_{trigger} is set equal to B_{MSY} / 2. Then
#' fishing mortality in the short forecast is calculated as:
#'
#' F(y+1) = F(y) * min{ 1, median[B(y+1) / MSY B_{trigger}] } /
#' median[F(y)/F_{MSY}
#'
#' Scenario 8 is similar to scenario 7, but includes assessment uncertainty in
#' the predictions by using the 35th percentile of the distributions of the
#' predicted catch, B/B_{MSY} and F/F_{MSY}.
#'
#' Dependent on the start of the management period (e.g. advice year), there
#' might be a time lag between the last observation and the start of the
#' management period, often referred to as the intermediate period. If this is
#' the case, an assumption about the catch during intermediate time period (e.g.
#' assessment year) has to be made. Two meaningful assumptions are:
#'
#' \itemize{
#' \item{1:}{The catch in the intermediate period is based on the fishing
#' mortality which is extrapolated from the previous year. This is the default
#' assumption;}
#' \item{2:}{The catch in the intermediate period is directly specified. This
#' could for example be the TAC recommended in the previous year. The catch can
#' be specified by means of the argument \code{intermediatePeriodCatch}. Be
#' aware that this catch might correspond to several years or a fraction of a
#' year depending on the time between the last observation and the start of the
#' management period. The function \code{\link{man.timeline}} can help
#' visualising the default or specified intermediate period in your data. The
#' argument \code{intermediatePeriodCatchSDFac} allows to specify the factor
#' with which to multiply the standard deviation of the catch (\eqn{\sigma_C})
#' with. It is thus a measure of the certainty around the catch in the
#' intermediate period. The argument \code{intermediatePeriodCatchList} allows
#' to define a list with catches and their intervals. It is a list with the
#' elements 'obsC', 'timeC', 'dtc' and the optional element 'stdevfacC' (which
#' is equal to 1 if not provided).}}
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' repman <- manage(rep, c(2,4,8))
#' sumspict.manage(repman) # To print projections
#'
#' @export
manage <- function(rep, scenarios = 'all',
                   maninterval = NULL,
                   maneval = NULL,
                   intermediatePeriodCatch = NULL,
                   intermediatePeriodCatchSDFac = 1,
                   intermediatePeriodCatchList = NULL,
                   verbose = TRUE,
                   dbg = 0){
    repin <- rep

    ## checks
    check.rep(rep)

    ## scenarios in index or name
    scenariosAll <- c("currentCatch", "currentF", "Fmsy", "noF","redF25",
                      "incrF25","msyHockeyStick","ices")
    if(all(is.numeric(scenarios))){
        ind <- scenarios %in% 1:8
        if(any(!ind) && verbose) cat("Scenario(s): ", scenarios[which(!ind)],
                                     " outside of range of possible scenarios: 1-8\n")
        scenarios <- scenariosAll[scenarios[ind]]
    }else if(scenarios[1] == "all"){
        scenarios <- scenariosAll
    }
    scenarios <- as.character(scenarios)
    indscenarios <- which(scenariosAll %in% scenarios)
    if(verbose){
        if(length(indscenarios) == 0){
            cat("No matching scenario found.\n")
        }else{
            cat("Selected scenario(s): ",paste(scenariosAll[indscenarios], collapse = ", ")," \n")
        }
    }

    ##  check if management time within model time
    if(!is.null(maninterval) || !is.null(maneval)){


        repx <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)

        repx$inp$timeCpred + repx$inp$dtcp

    }else rep <- rep

    ## remove any previously used ffac from data
    rep$inp$ffacvec <- make.ffacvec(rep$inp,1)$ffacvec

    timelastobs <- rep$inp$timerangeObs[2] ## rep$inp$time[rep$inp$indlastobs]
    if(!rep$inp$timepredc < timelastobs){
        ## mange overwrites all scenarios
        rep$man <- NULL

        if (1 %in% indscenarios){
            # 1. Keep current catch
            repc <- rep
            ## use Cp of ffac=1 scenario for intermediate period
            inttime <- rep$inp$dtpredcinds[1] - min(rep$inp$indpred)
            if(inttime > 0 && is.null(intermediatePeriodCatch) &&
               is.null(intermediatePeriodCatchList)){
                ny <- inttime * rep$inp$dteuler
                ## in case intermediate period spans several years
                cips <- list()
                timecs <- list()
                dtcs <- list()
                while(ny > 0){
                    if(length(cips) > 0){
                        lasttimec <- timecs[[length(timecs)]][2]
                        ipcList <- list(timeC = unlist(lapply(timecs,"[[",1)),
                                        obsC = unlist(cips),
                                        dtc = unlist(dtcs))
                    }else{
                        lasttimec <- max(rep$inp$timeC + rep$inp$dtc)
                        ipcList <- NULL
                    }
                    if(ny > 1){
                        timeInt<- seq(lasttimec, min(rep$inp$maninterval),1)[1:2]
                    }else{
                        timeInt <- c(lasttimec, min(rep$inp$maninterval))
                    }
                    cips[[length(cips)+1]] <- get.TAC(repc,
                                                      intermediatePeriodCatchList = ipcList,
                                                      maninterval = timeInt,
                                                      ffac = 1.0, verbose = FALSE)
                    timecs[[length(timecs)+1]] <- timeInt
                    dtcs[[length(cips)+1]] <- diff(timeInt)
                    ny = ny - 1
                }
                intermediatePeriodCatchList <- list(timeC = unlist(lapply(timecs,"[[",1)),
                                                    obsC = unlist(cips),
                                                    dtc = unlist(dtcs))
            }
            rep <- add.man.scenario(rep, scenarioTitle = "currentCatch",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      intermediatePeriodCatchList = intermediatePeriodCatchList,
                                      cfac = 1.0, csdfac = 1.0, verbose = FALSE, mancheck = FALSE)
        }
        if (2 %in% indscenarios){
            # 2. Keep current F
            rep <- add.man.scenario(rep, scenarioTitle = "currentF",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      ffac = 1.0, verbose = FALSE, mancheck = FALSE)
        }
        if (3 %in% indscenarios){
            # 3. Fish at Fmsy
            rep <- add.man.scenario(rep, scenarioTitle = "Fmsy",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      verbose = FALSE, mancheck = FALSE)
        }
        if (4 %in% indscenarios){
            # 4. No fishing, reduce to 0.1% of last F
            rep <- add.man.scenario(rep, scenarioTitle = "noF",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      ffac = 0.001, verbose = FALSE, mancheck = FALSE)
        }
        if (5 %in% indscenarios){
            # 5. Reduce F by 25%
            rep <- add.man.scenario(rep, scenarioTitle = "redF25",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      ffac = 0.75, verbose = FALSE, mancheck = FALSE)
        }
        if (6 %in% indscenarios){
            # 6. Increase F by 25%
            rep <- add.man.scenario(rep, scenarioTitle = "incrF25",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      ffac = 1.25, verbose = FALSE, mancheck = FALSE)
        }
        if (7 %in% indscenarios){
            # 7. Fish at Fmsy with hockey stick rule
            #    (F is equal to Fmsy if B > MSYBtrigger. F is reduced linearly to zero if B < MSYBtrigger)
            rep <- add.man.scenario(rep, scenarioTitle = "msyHockeyStick",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      breakpointB = 0.5, verbose = FALSE, mancheck = FALSE)
        }
        if (8 %in% indscenarios){
            # 8. Fish at Fmsy with hockey stick rule plus 35th percentile
            #    (same as 7. with 35th percentile of the catch, BBmsy and FFmsy distributions.)
            rep <- add.man.scenario(rep, scenarioTitle = "ices",
                                      maninterval = maninterval,
                                      maneval = maneval,
                                      intermediatePeriodCatch = intermediatePeriodCatch,
                                      intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                                      breakpointB = 0.5,
                                      fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35),
                                      verbose = FALSE, mancheck = FALSE)
        }
    }else{
        stop("Could not do management calculations because prediction horizon is too short. Increase the management interval 'maninterval'.")
    }
    ## use base spict object
    repout <- repin
    repout$man <- rep$man
    return(repout)
}


#' @name sumspict.manage
#'
#' @title Print management summary.
#'
#' @param rep A result report as generated by running \code{manage} or \code{add.man.scenario}.
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param timeline (default: FALSE)
#' @param verbose Should detailed outputs be provided (default: TRUE).
#'
#' @return Data frame containing management summary.
#'
#' @examples
#' \dontrun{
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' repman <- manage(rep, c(2,4,8))
#' sumspict.manage(repman)
#' }
#'
#' @export
sumspict.manage <- function(rep, include.EBinf=FALSE, include.unc=TRUE, timeline = TRUE, verbose=TRUE){
    repin <- rep

    if(!any(names(repin) == "man"))
        stop("Management calculations not found, 'run manage()' or 'add.man.scenario()' to include them.")

    repman <- repin$man

    ## check maninterval
    mancheck <- check.man(repin, verbose=FALSE)

    # Calculate percent difference
    get.pdelta <- function(parname, repman){
        indstart <- which(repman$inp$time == min(repman$inp$maninterval))
        indnext <- which(repman$inp$time == max(repman$inp$maninterval))
        val <- get.par(parname, repman, exp=TRUE)[indstart, 2]
        val1 <- get.par(parname, repman, exp=TRUE)[indnext, 2]
        return(round((val1 - val)/val*100, 1))
    }

    scenarios <- names(repman)
    if(any(scenarios == "")){
        scenarios[which(scenarios == "")] <- paste0("customScenario_", seq(length(which(scenarios == ""))))
    }
    names(repman) <- scenarios
    nsc <- length(scenarios)

    Cn <- paste0('C')
    Bn <- paste0('B')
    Fn <- paste0('F')
    get.cn <- function(nn){
        nc <- nchar(nn)
        tl <- 7 # Total length
        # Add spaces
        #pad <- ifelse(include.unc, paste0(rep(' ', max(0, tl-nc)), collapse=''), '')
        pad <- ''
        return(c(paste0(nn, '.lo'), paste0(pad, nn), paste0(nn, '.hi')))
    }
    BBn <- paste0('BqBmsy') # Should use / instead of q, but / is not accepted in varnames
    FFn <- paste0('FqFmsy')
    EBinfBn <- paste0('EBinfqBmsy')
    Cnextyear <- matrix(0, nsc, 3)
    colnames(Cnextyear) <- get.cn(Cn)
    Bnextyear <- matrix(0, nsc, 3)
    colnames(Bnextyear) <- get.cn(Bn)
    Fnextyear <- matrix(0, nsc, 3)
    colnames(Fnextyear) <- get.cn(Fn)
    BBnextyear <- matrix(0, nsc, 3)
    colnames(BBnextyear) <- get.cn(BBn)
    FFnextyear <- matrix(0, nsc, 3)
    colnames(FFnextyear) <- get.cn(FFn)
    perc.dB <- numeric(nsc)
    perc.dF <- numeric(nsc)
    EBinf <- numeric(nsc)

    for(i in 1:nsc){
        rp <- repman[[ scenarios[i] ]]
        EBinf[i] <- get.EBinf(rp)
        perc.dB[i] <- get.pdelta('logB',rp)
        perc.dF[i] <- get.pdelta('logF',rp)
        indnext <- which(rp$inp$time == max(rp$inp$maninterval))
        indnextC <- which((rp$inp$timeCpred + rp$inp$dtcp) == max(rp$inp$maninterval))
        Cnextyear[i, ] <- round(get.par('logCpred', rp, exp=TRUE)[indnextC, 1:3], 1)
        Bnextyear[i, ] <- round(get.par('logB', rp, exp=TRUE)[indnext, 1:3], 1)
        Fnextyear[i, ] <- round(get.par('logF', rp, exp=TRUE)[indnext, 1:3], 3)
        BBnextyear[i, ] <- round(get.par('logBBmsy', rp, exp=TRUE)[indnext, 1:3], 3)
        FFnextyear[i, ] <- round(get.par('logFFmsy', rp, exp=TRUE)[indnext, 1:3], 3)
    }
    indnextCrep <- which((rp$inp$timeCpred+rp$inp$dtcp) == max(rp$inp$maninterval))
    FBtime <- fd(max(rp$inp$maninterval))
    Ctime1 <- fd(rp$inp$timeCpred[indnextCrep])
    Ctime2 <- fd(rp$inp$timeCpred[indnextCrep]+rp$inp$dtcp[indnextCrep])
    if (!verbose && mancheck$mantime){
        Cn <- paste0('C', Ctime1)
        Bn <- paste0('B', FBtime)
        Fn <- paste0('F', FBtime)
    }

    # Data frame with predictions
    if(!mancheck$inter){
        perc.dB <- rep(NaN,nsc)
        perc.dF <- rep(NaN,nsc)
    }
    df <- cbind(Cnextyear[, 2], Bnextyear[, 2], Fnextyear[, 2], BBnextyear[, 2],
                FFnextyear[, 2], perc.dB, perc.dF)
    colnames(df)[1:5] <- c(Cn, Bn, Fn, BBn, FFn)
    qinds <- grep('q', colnames(df))
    colnames(df)[qinds] <- sub('q', '/', colnames(df)[qinds]) # Replace q with /
    # Data frame with uncertainties of absolute predictions
    inds <- c(1, 3)
    dfabs <- cbind(Cnextyear[, inds,drop=FALSE], Bnextyear[, inds,drop=FALSE], Fnextyear[, inds,drop=FALSE])
    colnames(dfabs) <- c(colnames(Cnextyear)[inds], colnames(Bnextyear)[inds],
                         colnames(Fnextyear)[inds])
    # Data frame with uncertainties of relateive predictions
    dfrel <- cbind(BBnextyear[, inds,drop=FALSE], FFnextyear[, inds,drop=FALSE])
    colnames(dfrel) <- c(colnames(BBnextyear)[inds], colnames(FFnextyear)[inds])
    qinds <- grep('q', colnames(dfrel))
    colnames(dfrel)[qinds] <- sub('q', '/', colnames(dfrel)[qinds]) # Replace q with /
    # Set row names
    rn <- suppressMessages(unlist(
        plyr::revalue(scenarios, replace = list("currentCatch" = 'Keep current catch',
                                                "currentF" = 'Keep current F',
                                                "Fmsy" = 'Fish at Fmsy',
                                                "noF" = 'No fishing',
                                                "redF25" = 'Reduce F 25%',
                                                "incrF25" = 'Increase F 25%',
                                                "msyHockeyStick" = 'MSY hockey-stick rule',
                                                "ices" = 'ICES advice rule'))))
    rn <- paste0(paste0(seq(length(rn)),". "),rn, "")
    rownames(df) <- rn
    rownames(dfrel) <- rn
    rownames(dfabs) <- rn
    #cat('Management summary\n')
    timerangeI <- range(unlist(rep$inp$timeI))
    timerangeC <- range(rep$inp$timeC)
    lastcatchseen <- tail(rep$inp$timeC+rep$inp$dtc, 1)
    # Start printing stuff
    if(verbose){ # Time interval information
        if(!timeline){
            cat(paste0('Observed interval, index:  ',
                       fd(timerangeI[1]),
                       ' - ',
                       fd(timerangeI[2]),
                       '\n'))
            cat(paste0('Observed interval, catch:  ',
                       fd(timerangeC[1]),
                       ' - ',
                       fd(lastcatchseen),
                       '\n\n'))
            if(mancheck$mantime){
                cat(paste0('Fishing mortality (F) prediction: ',
                           FBtime, '\n'))
                cat(paste0('Biomass (B) prediction:           ',
                           FBtime, '\n'))
                cat(paste0('Catch (C) prediction interval:    ',
                           Ctime1,
                           ' - ',
                           Ctime2,
                           '\n\n'))
            }
            if (rep$inp$catchunit != ''){
                cat(paste('Catch/biomass unit:', rep$inp$catchunit, '\n\n'))
            }
        }else{
            man.timeline(repman[[1]]$inp, obsonly = !mancheck$mantime, verbose=FALSE)
            cat('\n')
        }
        cat('Predictions\n')
    }
    print(df)
    if (include.unc){
        cat('\n95% CIs of absolute predictions\n')
        print(dfabs)
        cat('\n95% CIs of relative predictions\n')
        print(dfrel)
    }

    if(verbose){
        if(!mancheck$mantime){
            cat("\nThe management intervals differ between scenarios! Predictions refer to different time periods and intervals. Information about the management period and percentage differences cannot be displayed correctly and are omitted.\n")
        }else if(!mancheck$inter){
            cat("\nThe assumptions of the intermediate period differ between scenarios, e.g. continuing the F process vs. constant catch. The percentage differences cannot be displayed correctly and are omitted.\n")
        }
    }

    invisible(df)

}


#' @name mansummary
#'
#' @title Print management summary.
#'
#' @param repin A result report as generated by running \code{manage} or \code{add.man.scenario}.
#' @param include.EBinf Include EBinf/Bmsy in the output.
#' @param include.unc Include uncertainty of management quantities.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#'
#' @seealso sumspict.manage
#'
#' @return Data frame containing management summary.
#'
#' @examples
#' \dontrun{
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' repman <- manage(rep, c(2,4,8))
#' sumspict.manage(repman) # To print projections
#' }
#' @export
mansummary <- function(repin, include.EBinf=FALSE, include.unc=TRUE, verbose=TRUE){
    sumspict.manage(rep = repin,  timeline = FALSE,
                    include.EBinf=include.EBinf, include.unc=include.unc, verbose=verbose)
}


#' @name check.man.time
#' @title Checks and corrects management time to be within model time
#'
#' @param x Either an input list from \code{check.inp} or a result report as
#'     generated by running \code{fit.spict}.
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: maninterval = c(2020.25,2021.25). Default:
#'     NULL.
#' @param maneval Time at which to evaluate model states. Example: maneval =
#'     2021.25. Default: NULL.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param printTimeLine logical; print the management time line (default: TRUE)
#'
#' @return Updated input list or fitted spict object dependent on type of input.
#'
#' @examples
#' data(pol)
#' inp <- check.inp(pol$albacore)
#' rep <- fit.spict(inp)
#'
#' ## with an input list
#' check.man.time(inp)
#'
#' ## with an output list
#' check.man.time(rep)
#'
#' @export
check.man.time <- function(x, maninterval = NULL, maneval = NULL, verbose = TRUE, printTimeline = TRUE){

    if(!inherits(x, "spictcls")){
        x <- try(check.inp(x, verbose = FALSE, mancheck=FALSE), silent=TRUE)
        if(inherits(x, "try-error")){
            stop("Provided object 'x' needs to be an input list or a fitted spict object!")
        }
    }

    isrep <- ifelse(inherits(x, "spictcls") && "opt" %in% names(x), 1, 0)

    if(isrep){
        repin <- x
        inpin <- x$inp
    }else{
        repin <- list()
        inpin <- x
    }

    ## update man args
    if(!is.null(maninterval)) inpin$maninterval <- maninterval
    if(!is.null(maneval)) inpin$maneval <- maneval

    ## affected, but overwritten by check.inp:
    ## indpred, indCpred, ns, time, dt, seasons, seasonindex, seasonindex2, ir, isdf, ic, nc, nobsCp, dtcp, timeCpred

    ## affected:
    varNull <- c("logmcovariatein","ffacvec","fconvec", "MSYregime")
    varIniNull <- c("logF","logB","logmre","logu")

    ## adjust management interval if before last catch obs
    maxtimeC <- max(inpin$timeC + inpin$dtc)
    minint <- min(inpin$maninterval)
    maxint <- max(inpin$maninterval)

    if(minint < maxtimeC){
        manintstart <- maxtimeC
        manintend <- maxint
        manintend <- ifelse(manintend > manintstart, manintend, manintstart + (maxint-minint))
        if(verbose) cat("The specified management interval [",
                        inpin$maninterval[1],",",inpin$maninterval[2],
                        "] must start at or after the last catch observation interval: ",
                        maxtimeC,"! The management interval [",
                        manintstart,",",manintend,"] is used instead.\n")
        inpin$maninterval <- c(manintstart, manintend)
    }
    inpin <- check.inp(inpin, verbose = FALSE, mancheck=FALSE)
    repin$inp <- inpin

    ## extend model time if management times not included
##    if(max(inpin$maninterval, inpin$maneval) > max(inpin$time)){
        ## 1. correcting inp list
        ## overwrite time vectors with wrong lengths
        if(verbose) cat(c("Model time is not equal to specified projection time. Adjusting time-dependent variables in 'inp': ",
                          paste0(c(varNull,paste0("ini$",varIniNull)),collapse=", ")),"\n")
        inpout <- inpin
        for(i in varNull) inpout[i] <- NULL
        for(i in varIniNull) inpout$ini[i] <- NULL
        inpout <- check.inp(inpout, verbose = FALSE, mancheck=FALSE)
        ## try to restore management (new manstart might be outside of inital time period)
        ffac <- inpin$ffacvec[which(inpout$time == inpout$maninterval[1])]
        ffac <- ifelse(is.na(ffac), 1, ffac)
        inpout <- make.ffacvec(inpout, ffac)
        fcon <- inpin$fconvec[which(inpout$time == inpout$maninterval[1])]
        fcon <- ifelse(is.na(fcon), 1e-8, fcon)
        inpout <- make.fconvec(inpout, fcon)
        ## restore prod regimes
        dtdiff <- length(inpout$MSYregime) - length(inpin$MSYregime)
        rlein <- rle(inpin$ir)
        ls <- length(rlein$lengths)
        rleout <- rlein
        rleout$lengths[ls] <- rleout$lengths[ls] + dtdiff
        inpout$ir <- inverse.rle(rleout)
        inpout$MSYregime <- as.factor(inpout$ir)
        inpout$noms <- inpin$noms
        ## 2. correcting rep list
        if(isrep){
            xout <- retape.spict(repin, inpout, verbose = verbose, mancheck=FALSE)
        }else{
            xout <- inpout
        }
    ## }else{
    ##     if(isrep){
    ##         xout <- repin
    ##     }else{
    ##         xout <- inpin
    ##     }
    ## }
    if(verbose && printTimeline) man.timeline(inpin, verbose = FALSE)
    return(xout)
}

#' @name check.catchList
#' @title Check catch list
#'
#' @param catchList List obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided)
#' @param sdfac Factor for the multiplication of the standard deviation of the
#'     catch (default: 1).
#'
#' @details Internal function that checks if catchList is complete.
#'
#' @return Checked catchList
check.catchList <- function(catchList, sdfac = 1){
    if(!"obsC" %in% names(catchList)) stop("Element 'obsC' is missing.")
    if(!"timeC" %in% names(catchList)) stop("Element 'timeC' is missing.")
    if(!"dtc" %in% names(catchList)) stop("Element 'dtc' is missing.")

    if(length(catchList$obsC) != length(catchList$timeC))
        stop("The length of the elements of the catchList have to be equal.")
    if(length(catchList$obsC) != length(catchList$dtc))
        stop("The length of the elements of the catchList have to be equal.")

    if(!"stdevfacC" %in% names(catchList))
        catchList$stdevfacC <- rep(sdfac,length(catchList$obsC))

    return(catchList)
}



#' @name make.man.inp
#' @title Get updated inp list based on specific HCR
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarioTitle Title of scenario (default: \code{'customScenario_X'},
#'     where X corresponds to a numeric counting equal to the numer of scenarios
#'     with this name in \code{rep$man} plus 1, e.g. \code{'customScenario_3'}).
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: \code{maninterval = c(2020.25,2021.25)}.
#'     Default: NULL.
#' @param maneval Time at which to evaluate model states. Example: \code{maneval
#'     = 2021.25}. Default: NULL.
#' @param ffac Factor to multiply current fishing mortality by (default: 1).
#' @param cfac Factor to multiply current catch by (default: 1). Please refer to
#'     the details for more information.
#' @param csdfac Factor for the multiplication of the standard deviation of the
#'     catch (default: 1). Please refer to the details for more information.
#' @param fractiles List defining the fractiles of the 3 distributions of
#'     'catch', 'bbmsy', and 'ffmsy'. By default (0.5) median is used for all 3
#'     quantities. Please refer to the details for more information.
#' @param breakpointBBmsy Breakpoint in terms of \eqn{B/B_{MSY}} for the
#'     hockey-stick HCR. By default (0) no breakpoint is assumed. Please refer
#'     to the details for more information.
#' @param safeguardB List defining an optional precautionary buffer by means of
#'     a biomass reference level relative to \eqn{B/B_{MSY}} (\code{'limitB'};
#'     default: 0, i.e. deactivating the PA buffer) and the risk aversion
#'     probability (\code{'prob'}; default: 0.95). Please refer to the details
#'     for more information.
#' @param intermediatePeriodCatch Catch during intermediate period, e.g. last
#'     year's TAC (default: \code{NULL}). Please refer to the details for more
#'     information.
#' @param intermediatePeriodCatchSDFac Factor for the multiplication of the
#'     standard deviation of the catch during the intermediate period (default:
#'     1). Please refer to the details for more information.
#' @param intermediatePeriodCatchList List defining catch in the intermediate
#'     period obtaining the elements 'obsC', 'timeC', and 'dtc' (optional
#'     element 'stdevfacC' which is 1 if not provided). Please refer to the
#'     details for more information.
#' @param catchList List obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided). Please refer
#'     to the details for more information.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @param checkman Should the time-dependent objects in \code{inp} be checked
#'     against the management time and corrected if necessary? (Default: TRUE)
#'
#' @details Internal function that creates the required input list for the
#'     specific HCR. For detailed information, please refer to
#'     \code{\link{add.man.scenario}}.
#'
#' @return The updated inp list based on specified HCR.
make.man.inp <- function(rep, scenarioTitle = "",
                         maninterval = NULL,
                         maneval = NULL,
                         ffac = NULL,   ## if NULL default fishing at fmsy
                         cfac = NULL,
                         csdfac = 1,
                         fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5),
                         breakpointB = 0,
                         safeguardB = list(limitB = 0, prob = 0.95),
                         intermediatePeriodCatch = NULL,
                         intermediatePeriodCatchSDFac = 1,
                         intermediatePeriodCatchList = NULL,
                         catchList = NULL,
                         verbose = TRUE,
                         dbg = 0,
                         mancheck = TRUE){

    ## check rep class
    check.rep(rep, reportmode0 = FALSE)

    ## check manintervals of existing rep$man
    if(is.null(maninterval)){
        manint <- rep$inp$maninterval
    }else manint <- maninterval
    checkScenarios <- check.man(rep, maninterval=manint, verbose=FALSE)
    if(any(names(rep)=="man")){
        if(checkScenarios$mantime){
            if(is.null(maninterval)) maninterval <- rep$man[[1]]$inp$maninterval
            if(is.null(maneval)){maneval <- max(maninterval)
                if(verbose) cat(paste0("The management evaluation time 'maneval' was not specified. Setting 'maneval' to the end of the management period: ", maneval, "\n"))
            }
        }else if(verbose) cat(paste0("The default/specified management interval: ",manint[1]," - ",manint[2],
                                         " differs from existing scenarios in rep$man.\n"))
    }
    ## check if management time within model time
    if((!is.null(maninterval) || !is.null(maneval)) && mancheck){
        repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)
    }else repin <- rep

    ## check input variables
    stopifnot(all(unlist(fractiles) <= 0.5 && unlist(fractiles) > 0))
    stopifnot(cfac >= 0)
    stopifnot(csdfac >= 0)
    stopifnot(ffac >= 0)
    stopifnot(breakpointB >= 0)
    if(is.numeric(ffac) && is.numeric(cfac))
        stop("Both 'ffac' and 'cfac' provided, please choose either or neither.")

    ## copies
    repout <- reppa <- repin
    inpin <- repin$inp


    ## FRACTILES
    if(!is.list(fractiles)) stop("Please provide 'fractiles' with the arguments: 'catch', 'bbmsy', and 'ffmsy'!")
    default_fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5)
    fList <- default_fractiles[which(!names(default_fractiles) %in% names(fractiles))]
    fList <- c(fList,fractiles)

    ## BIOMASS SAFEGUARD
    if(!is.list(safeguardB)) stop("Please provide 'safeguardB' with the arguments: 'limitB' and 'prob'!")
    default_safeguardB = list(limitB = 0, prob = 0.95)
    pList <- default_safeguardB[which(!names(default_safeguardB) %in% names(safeguardB))]
    pList <- c(pList,safeguardB)

##    browser()

    ## fixed catch in INTERMEDIATE YEAR
    inttime <- inpin$dtpredcinds[1] - min(inpin$indpred)
    if(inttime > 0 && ((!is.null(intermediatePeriodCatch) &&
                        !is.na(intermediatePeriodCatch) && is.numeric(intermediatePeriodCatch)) ||
                       !is.null(intermediatePeriodCatchList))){
        inpt <- inpin
        dtcint <- (inpin$dtpredcinds[1] - min(inpin$indpred)) * inpin$dteuler
        if(verbose) writeLines(paste0("The intermediate time period is ",dtcint," year(s) long. The catch 'intermediatePeriodCatch' should be representative of that period.\n"))
        if(is.null(intermediatePeriodCatchList)){
            ## default catchList
            inpt$timeC <- c(inpt$timeC, inpin$time[min(inpin$indpred)])
            inpt$obsC <- c(inpt$obsC, intermediatePeriodCatch)
            inpt$stdevfacC <- c(inpt$stdevfacC, intermediatePeriodCatchSDFac)
            inpt$dtc <- c(inpt$dtc, dtcint)
        }else{
            ## specified catchList
            check.catchList(intermediatePeriodCatchList)
            inpt$timeC <- c(inpt$timeC, intermediatePeriodCatchList$timeC)
            inpt$obsC <- c(inpt$obsC, intermediatePeriodCatchList$obsC)
            if(is.null(intermediatePeriodCatchList$stdevfacC)){
                inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(intermediatePeriodCatchList$timeC)))
            }else{
                inpt$stdevfacC <- c(inpt$stdevfacC, intermediatePeriodCatchList$stdevfacC)
            }
            inpt$dtc <- c(inpt$dtc, intermediatePeriodCatchList$dtc)
        }
        inpt <- check.inp(inpt, verbose = FALSE, mancheck=FALSE)
        inpt$timerangeObs <- inpin$timerange
        repout <- reppa <- repin <- retape.spict(repin, inpt, verbose = FALSE, mancheck=FALSE)
        inpin <- repin$inp
    }

    ## QUANTITIES
    fmanstart <- get.par('logFm', repin, exp=TRUE)[2]
    fmsy <- get.par('logFmsy', repin, exp=TRUE)[2]
    bmsy <- get.par('logBmsy', repin, exp=TRUE)[2]
    logFpFmsy <- get.par("logFpFmsynotS", repin)
    logBpBmsy <- get.par("logBpBmsy", repin)
    logFmFmsy <- get.par("logFmFmsynotS", repin)
    logBmBmsy <- get.par("logBmBmsy", repin)


    ## ADVICE RULES
    ## ---------------
    if(!is.numeric(cfac) || is.na(cfac)){
        if(!is.numeric(ffac) || is.na(ffac)){
            ## FFmsy component
            fi <- 1 - fList$ffmsy
            fmfmsyi <- exp(qnorm(fi, logFmFmsy[2], logFmFmsy[4]))
            fmfmsy5 <- exp(qnorm(0.5, logFmFmsy[2], logFmFmsy[4]))
            fred <- fmfmsy5 / fmfmsyi
            ## BBmsy component (hockey stick HCR)
            if(!is.na(breakpointB) && is.numeric(breakpointB) && breakpointB != 0){
                bmbmsyi <- 1/breakpointB * exp(qnorm(fList$bbmsy, logBmBmsy[2], logBmBmsy[4]))
                fred <- fred * min(1, bmbmsyi)
            }
            ## F reduction factor
            ffac <- (fred + 1e-8) * fmsy / fmanstart
            ## PA component
            if(!is.na(pList$limitB) && is.numeric(pList$limitB) && pList$limitB != 0){
                inppa <- make.ffacvec(inpin, ffac)
                inppa$reportmode <- 1
                reppa <- try(retape.spict(reppa, inppa, verbose=verbose, mancheck=FALSE), silent=TRUE)
                if(inherits(reppa,"try-error")){
                    if(verbose) cat("The fishing mortality multiplication factor 'ffac' could not be estimated with this management scenario due to an error when retaping the updated spict model. 'ffac' is set to 1, which assumes no change in the fishing mortality. \n")
                    ffac <- 1
                }else{
                    logBpBmsyPA <- get.par("logBpBmsy", reppa)
                    probi <- 1 - pList$prob
                    bpbmsyiPA <- exp(qnorm(probi, logBpBmsyPA[2], logBpBmsyPA[4]))
                    if((bpbmsyiPA - pList$limitB) < -1e-3){
                        ffac <- try(get.ffac(reppa, ref=pList$limitB,
                                             problevel=pList$prob,
                                             var="logBpBmsy",
                                             reportmode = 1), silent=TRUE)
                        if(inherits(ffac,"try-error")){
                            if(verbose) cat("The fishing mortality multiplication factor 'ffac' could not be estimated with this management scenario due to an error when optimising the risk aversion probability over F. 'ffac' is set to 1, which assumes no change in the fishing mortality. \n")
                            ffac <- 1
                        }

                    }
                }
            }
        }
        inpt <- make.ffacvec(inpin, ffac)
    }else{
        ## Fishing with provided catch
        inpt <- inpin
        if(is.null(catchList)){

            ## Default catch during maninterval preserving seasonality
            ## observation indices representative of the last full year
            indFullYear = (length(inpin$timeC) - (which(cumsum(rev(diff(inpin$timeC))) == 1)-1)) :
                length(inpin$timeC)
            timeLastC <- inpin$timeC[indFullYear]
            obsLastC <- inpin$obsC[indFullYear]
            dtc <- inpin$dtc
            dtcLastC <- c(dtc,dtc[length(dtc)])[indFullYear]
            mindtc <- min(dtcLastC)
            tmpTime <- inpin$timeCpred

            ## management indices
            manint <- inpin$maninterval
            manperiod <- max(manint) - min(manint)
            manperiodYears <- floor(manperiod)
            manperiodSpanYear <- floor(manint[2]) - floor(manint[1])
            maninds <- which(tmpTime >= min(inpin$maninterval))

            ## match man indices to obs indices
            potcatchTimes <- timeLastC ##unique(c(timeLastC, timeLastC + dtcLastC))
            potcatchTimeYear <- potcatchTimes %% min(floor(potcatchTimes))
            potcatchTimeYears <- rep(potcatchTimeYear,manperiodSpanYear+1) +
                rep(0:manperiodSpanYear,each = length(potcatchTimeYear))
            mantimes <- seq(potcatchTimeYears[which.min(abs(potcatchTimeYears-(manint[1] %% 1)))],
                            potcatchTimeYears[which.min(abs(potcatchTimeYears-(manint[2] %% 1 +
                                                                               manperiodSpanYear - mindtc)))],
                            by = mindtc)
            catchTimeYears <- potcatchTimeYears[potcatchTimeYears %in% mantimes]

            ## sum
            indi <- match((catchTimeYears %% 1), potcatchTimeYears)
            obsint <- range(c(timeLastC[indi],
                    timeLastC[indi] +
                    dtcLastC[indi]))
            manC <- sum(obsLastC[indi])
            shortlong <- ifelse(manperiod >= diff(range(obsint)), "shorter", "longer")

            if(verbose && manperiod != diff(range(obsint)))
                cat(paste0("The catch observations do not allow to set a representative default catch for the specified management interval [",manint[1],",",manint[2],"], the catch observations representative of the ",shortlong," interval [",obsint[1],",",obsint[2],"] are used. Use the argument 'catchList' to specify the catch for the management period or change the management period to correspond to a multiple of the catch observation intervals in the last year with catch observations.\n"))

            ## default catchList
            inpt$timeC <- c(inpt$timeC, tmpTime[maninds])
            inpt$obsC <- c(inpt$obsC, rep(manC * cfac, length(maninds)))
            inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(maninds)))
            inpt$dtc <- c(inpt$dtc, rep(inpt$dtpredc, length(maninds)))
        } else {
            ## specified catchList
            check.catchList(catchList)
            inpt$timeC <- c(inpt$timeC, catchList$timeC)
            inpt$obsC <- c(inpt$obsC, catchList$obsC)
            if(is.null(catchList$stdevfacC)){
                inpt$stdevfacC <- c(inpt$stdevfacC, rep(csdfac, length(catchList$timeC)))
            }else{
                inpt$stdevfacC <- c(inpt$stdevfacC, catchList$stdevfacC)
            }
            inpt$dtc <- c(inpt$dtc, catchList$dtc)
        }
        inpt <- check.inp(inpt, verbose = FALSE, mancheck = FALSE)
    }

    ## return updated inp list
    return(inpt)
}


#' @name add.man.scenario
#' @title Define management scenario
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarioTitle Title of scenario (default: \code{'customScenario_X'},
#'     where X corresponds to a numeric counting equal to the numer of scenarios
#'     with this name in \code{rep$man} plus 1, e.g. \code{'customScenario_3'}).
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: \code{maninterval = c(2020.25,2021.25)}.
#'     Default: NULL.
#' @param maneval Time at which to evaluate model states. Example: \code{maneval
#'     = 2021.25}. Default: NULL.
#' @param ffac Factor to multiply current fishing mortality by (default: 1).
#' @param cfac Factor to multiply current catch by (default: 1). Please refer to
#'     the details for more information.
#' @param csdfac Factor for the multiplication of the standard deviation of the
#'     catch (default: 1). Please refer to the details for more information.
#' @param fractiles List defining the fractiles of the 3 distributions of
#'     'catch', 'bbmsy', and 'ffmsy'. By default (0.5) median is used for all 3
#'     quantities. Please refer to the details for more information.
#' @param breakpointBBmsy Breakpoint in terms of \eqn{B/B_{MSY}} for the
#'     hockey-stick HCR. By default (0) no breakpoint is assumed. Please refer
#'     to the details for more information.
#' @param safeguardB List defining an optional precautionary buffer by means of
#'     a biomass reference level relative to \eqn{B/B_{MSY}} (\code{'limitB'};
#'     default: 0, i.e. deactivating the PA buffer) and the risk aversion
#'     probability (\code{'prob'}; default: 0.95). Please refer to the details
#'     for more information.
#' @param intermediatePeriodCatch Catch during intermediate period, e.g. last
#'     year's TAC (default: \code{NULL}). Please refer to the details for more
#'     information.
#' @param intermediatePeriodCatchSDFac Factor for the multiplication of the
#'     standard deviation of the catch during the intermediate period (default:
#'     1). Please refer to the details for more information.
#' @param intermediatePeriodCatchList List defining catch in the intermediate
#'     period obtaining the elements 'obsC', 'timeC', and 'dtc' (optional
#'     element 'stdevfacC' which is 1 if not provided). Please refer to the
#'     details for more information.
#' @param catchList List obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided). Please refer
#'     to the details for more information.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @param checkman Should the time-dependent objects in \code{inp} be checked
#'     against the management time and corrected if necessary? (Default: TRUE)
#'
#' @details The constant catch scenario can be modified with the argument
#'     \code{cfac}, which multiplies the respective previous catch with
#'     \code{cfac}. By default, the respective previous catch corresponds to
#'     that part of the previous year which corresponds to the management
#'     interval. For example, if the management period is \eqn{[1991,1992[}, the
#'     whole catch from the year \eqn{[1990,1991[} is being used. If the
#'     management period is \eqn{[1991.5,1991.75[}, the same interval from the
#'     previous year \eqn{[1990.5,1990.75[} is being used. If the management
#'     period spans several years, e.g. \eqn{[1991,1993[}, the whole catch from
#'     the previous year \eqn{[1990,1991[} is being used two times. However, any
#'     catch or vector of catches can be defined for different time intervals
#'     wihtin the management period by means of the argument \code{catchList}.
#'     This list contains the elements 'obsC', 'timeC', 'dtc', and the optional
#'     element 'stdevfacC' (which is 1 if not provided). Be aware that in this
#'     case the absolute catch specified in \code{catchList$obsC} is being used
#'     without the multiplication with \code{cfac}.
#'
#' The combination of the arguments in the "fractiles", "breakpointB", and
#'     "safeguardB" allow defining a number of different harvest control rules
#'     (HCRs):
#'
#'\itemize{
#' \item{Fishing at F_{MSY}: if \code{breakpointB == 0} and
#'     \code{safeguardB$limitB == 0} (default).}
#' \item{MSY hockey-stick rule: Fishing at F_{MSY} above a certain biomass reference
#'     level (here defined as a fraction of B_{MSY} with \code{breakpointB}).
#'     Below the reference level, fishing is reduced linearly to 0 as suggested in
#'     ICES (2017).}
#' \item{MSY (hockey-stick) rule with additional precautionary buffer: As long
#'     as the probability of the predicted biomass relative to a reference
#'     biomass level (e.g. 0.3 B_{MSY}, defined by \code{safeguardB$limitB}) is smaller or
#'     equal to a specified risk aversion probability (e.g. 95%, defined by
#'     \code{safeguardB$prob}), fishing at F_{MSY} or following the hockey-stick rule
#'     (if \code{breakpoint != 0}), otherwise reduce fishing mortality to meet
#'     specified risk aversion probability (\code{safeguardB$prob}) as introduced in
#'     ICES (2018).}
#' \item{By ICES (2019) recommended MSY hockey-stick rule with 35th percentiles:
#'     Fishing at 35th percentile of F_{MSY} above the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}} (\code{breakpointB = 0.5}) and 35th percentile of
#'     linearly reduced F_{MSY} below the 35th percentile of 0.5
#'     \eqn{B/B_{MSY}}. TAC corresponds to 35th percentile of predicted catch.
#'     Rule is applied with \code{fractiles = list(catch=0.35, bbmsy=0.35,
#'     ffmsy=0.35)}, \code{breakpointB = 0.5}, and \code{safeguardB =
#'     list(limitB = 0, prob = 0.95)}.}}
#'
#'
#' The arguments of the "fractiles" are:
#' \itemize{
#' \item{catch - Fractile of the predicted catch distribution. Default: 0.5.}
#' \item{bbmsy - Fractile of the \eqn{B/B_{MSY}} distribution. Default: 0.5.}
#' \item{ffmsy - Fractile of the \eqn{F/F_{MSY}} distribution. Default: 0.5.}}
#'
#' Note that the fractile for the \eqn{F/F_{MSY}} distribution is 1 minus the
#' fractile specified. As the current fishing mortality is divided by the value
#' of this distribution \eqn{F{y+1} = \frac{F_y}{F_y/F_{MSY}}}, a lower
#' percentile of the \eqn{F/F_{MSY}} distribution is more conservative than a
#' larger one. This allows a consistent setting of fractiles among the different
#' quantities.
#'
#' The argument list "safeguardB" includes:
#' \itemize{
#' \item{limitB - Reference level for the evaluation of the predicted biomass
#'   defined as fraction of \eqn{B/B_{MSY}}. By default (\code{safeguardB$limitB
#'   == 0}) the PA buffer is not used. Theoretically, any value smaller than 1
#'   is meaningful, but an ICES recommended value would be 30%
#'   \code{safeguardB$limitB = 0.3} (ICES, 2018).}
#' \item{prob - Risk aversion probability of the predicted biomass relative to
#'   specified reference level (\code{safeguardB$limitB}) for all rules with PA
#'   buffer (\code{safeguardB$limitB != 0}). Default: 0.95 as recommended by ICES
#'   (2018).}}
#'
#' Dependent on the start of the management period (e.g. advice year), there
#' might be a time lag between the last observation and the start of the
#' management period, often referred to as the intermediate period. If this is
#' the case, an assumption about the catch during intermediate time period (e.g.
#' assessment year) has to be made. Two meaningful assumptions are:
#'
#' \itemize{
#' \item{1:}{The catch in the intermediate period is based on the fishing
#' mortality which is extrapolated from the previous year. This is the default
#' assumption;}
#' \item{2:}{The catch in the intermediate period is directly specified. This
#' could for example be the TAC recommended in the previous year. The catch can
#' be specified by means of the argument \code{intermediatePeriodCatch}. Be
#' aware that this catch might correspond to several years or a fraction of a
#' year depending on the time between the last observation and the start of the
#' management period. The function \code{\link{man.timeline}} can help
#' visualising the default or specified intermediate period in your data. The
#' argument \code{intermediatePeriodCatchSDFac} allows to specify the factor
#' with which to multiply the standard deviation of the catch (\eqn{\sigma_C})
#' with. It is thus a measure of the certainty around the catch in the
#' intermediate period. The argument \code{intermediatePeriodCatchList} allows
#' to define a list with catches and their intervals. It is a list with the
#' elements 'obsC', 'timeC', 'dtc' and the optional element 'stdevfacC' (which
#' is equal to 1 if not provided).}}
#'
#' @return The fitted object based on specified HCR
#'
#' @references
#' ICES. 2017. Report of the Workshop on the Development of the ICES
#' approach to providing MSY advice for category 3 and 4 stocks
#' (WKMSYCat34), 6-10 March 2017, Copenhagen, Denmark. ICES CM 2017/
#' ACOM:47. 53 pp.
#'
#' ICES. 2018. Report of the Eighth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE VIII), 8-12 October 2018, Lisbon,
#' Portugal. ICES CM 2018/ACOM:40. 172 pp.
#'
#' ICES 2019. Report of the Ninth Workshop on the Development of
#' Quantitative Assessment Methodologies based on LIFE-history traits,
#' exploitation characteristics, and other relevant parameters for
#' data-limited stocks (WKLIFE IX), 30 September-4 October 2019,
#' Lisbon, Portugal.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#'
#' ## Fishing at Fmsy
#' add.man.scenario(rep)
#'
#' ## MSY hockey-stick rule
#' add.man.scenario(rep, breakpointB = 0.5)
#'
#' ## ICES (2019) recommended HCR
#' add.man.scenario(rep, fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35), breakpointB=0.5)
#'
#' @export
add.man.scenario <- function(rep, scenarioTitle = "",
                             maninterval = NULL,
                             maneval = NULL,
                             ffac = NULL,   ## if NULL default fishing at fmsy
                             cfac = NULL,
                             csdfac = 1,
                             fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5),
                             breakpointB = 0,
                             safeguardB = list(limitB = 0, prob = 0.95),
                             intermediatePeriodCatch = NULL,
                             intermediatePeriodCatchSDFac = 1,
                             intermediatePeriodCatchList = NULL,
                             catchList = NULL,
                             verbose = TRUE,
                             dbg = 0,
                             mancheck = TRUE){
    repout <- rep

    ## checks
    check.rep(rep, reportmode0 = FALSE)

    ## check if management time within model time
    if((!is.null(maninterval) || !is.null(maneval)) && mancheck){
        rep <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)
    }else rep <- rep

    ## remove any previously used ffac from data
    rep$inp$ffacvec <- make.ffacvec(rep$inp,1)$ffacvec

    ## get inpt for retape
    ## get updated inp
    inpt <- make.man.inp(rep=rep,
                         scenarioTitle = scenarioTitle,
                         maninterval = maninterval,
                         maneval = maneval,
                         ffac = ffac,
                         cfac = cfac,
                         csdfac = csdfac,
                         fractiles = fractiles,
                         breakpointB = breakpointB,
                         safeguardB = safeguardB,
                         intermediatePeriodCatch = intermediatePeriodCatch,
                         intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                         intermediatePeriodCatchList = intermediatePeriodCatchList,
                         catchList = catchList,
                         verbose = verbose,
                         dbg = dbg,
                         mancheck=FALSE)


    ## retape spict
    repman <- retape.spict(rep, inpt, verbose = FALSE, mancheck=FALSE)
    ## check if man already in repout
    if(!"man" %in% names(repout)){
        repout$man <- list()
        repout$man[[1]] <- repman
        if(scenarioTitle == "") scenarioTitle <- "customScenario_1"
        names(repout$man)[1] <- scenarioTitle
        # Create an baseline F trajectory with constant F and store
    }else{
        if(scenarioTitle == ""){  ## set customScenario name with counter
            custs <- strsplit(names(repout$man),"_")
            custind <- unlist(lapply(custs, function(x) "customScenario" %in% x))
            custcount <- min(1,ifelse(any(custind),
                                      max(as.numeric(unlist(lapply(custs[custind],
                                                                   function(x) x[[2]])))) + 1,1))
            scenarioTitle <- paste0("customScenario_", custcount)
            nman <- length(repout$man) + 1
            repout$man[[nman]] <- repman
            names(repout$man)[nman] <- scenarioTitle
        }else{
            taken <- names(repout$man) %in% scenarioTitle
            if(any(taken)){
                repout$man[[which(taken)]] <- repman
            }else{
                nman <- length(repout$man) + 1
                repout$man[[nman]] <- repman
                names(repout$man)[nman] <- scenarioTitle
            }
        }
    }
    ## check consistency in intermediate period
    mancheck <- check.man(repout, maninterval=maninterval, verbose=FALSE)
    if(!mancheck$inter && verbose)
        cat("The assumptions about the intermediate period differ between scenarios, e.g. continuing the F process vs. constant catch during the intermediate period.\n")
    return(repout)
}


#' @name probdev
#' @title Estimate deviation between targeted and realised probability of
#'     specified model variable hitting a specified reference level under given
#'     fishing mortality
#'
#' @param ffac Factor to multiply current fishing mortality by (default: 1)
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param var A variable of the spict model (default: "logBpBmsy").
#' @param ref Reference level relative to specified variable (default: 1)
#' @param problevel Probability level of the risk aversion (default: 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default: 1).
#' @param getFrac logical; return realised fraction of relative state (default:
#'     FALSE).
#' @param verbose logical; print realised fraction of relative state, fishing
#'     mortality factor, and deviation (default: FALSE).
#'
#' @return Returns deviation between targeted and realised probability of
#'     hitting specified reference levels under given fishing mortality
probdev <- function(ffac = 1, rep, var = "logBpBmsy", ref = 1,
                    problevel = 0.95, reportmode = 1, getFrac = FALSE,
                    verbose = FALSE){
    ## get F factor
    inpt <- make.ffacvec(rep$inp, ffac)
    inpt$reportmode <- reportmode
    rept <- retape.spict(rep, inpt, verbose=verbose, mancheck=FALSE)
    vart <- get.par(var,rept)
    ll <- qnorm(1 - problevel, vart[,2], vart[,4])
    dev <- (exp(ll) - ref)^2
    if(verbose)  cat("exp(ll): ",exp(ll),"ffac: ",ffac," dev: ",dev,"\n")
    if(getFrac) dev <- exp(ll)
    dev
}


#' @name get.ffac
#' @title Estimate fishing mortality factor minimising probability of specified
#'     model variable hitting a specified reference level under given fishing
#'     mortality
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param var A variable of the spict model (default: "logBpBmsy").
#' @param ref Reference level relative to specified variable (default: 1)
#' @param problevel Probability level of the risk aversion (default: 0.95).
#' @param reportmode Integer between 0 and 2 determining which objects will be
#'     adreported (default: 1).
#' @param verbose logical; print informative text (default: TRUE).
#'
#' @return Optimised Fishing mortality for P(Bp<Blim)
get.ffac <- function(rep, var = "logBpBmsy", ref = 1,
                     problevel=0.95, reportmode = 1,
                     verbose = TRUE){
    ## see if possible to hit target risk with zero F
    ffac0 <- probdev(ffac=1e-6, rep=rep, getFrac=TRUE, problevel=problevel,
                    var=var, ref = ref, reportmode=reportmode, verbose=FALSE)
    if(!is.finite(ffac0) || (ffac0 - ref) < -1e-3){
        if(verbose) cat("Not possible even with zero F\n")
        return(1e-6)
    }
    offac <- optimize(probdev, c(1e-6,5), tol=1e-2, rep=rep,
                      var=var, problevel=problevel,
                      ref=ref, reportmode=reportmode,
                      verbose=FALSE)
    offac$minimum
}


#' @name calc.tac
#' @title Calculate Total Allowable Catch (TAC)
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param inp Input list with ffac or catch observation corresponding to
#'     management. If \code{NULL} (default), the input list in \code{rep} is
#'     used.
#' @param fractileCatch The fractile of the catch distribution to be used for
#'     setting the TAC. Default (0.5) corresponds to the median.
#' @param exp Should tac be reported on natural scale? (default: TRUE)
#'
#' @return Total Allowable Catch (TAC)
#'
#' @export
calc.tac <- function(rep, inp = NULL, fractileCatch = 0.5, exp = TRUE){
    check.rep(rep, reportmode0 = FALSE)
    if(is.null(inp)) inp <- rep$inp
    inp$reportmode <- 2
    rept <- retape.spict(rep, inp, verbose=FALSE, mancheck=FALSE)
    if(fractileCatch == 0.5){
        tac <- rept$obj$report(rept$obj$env$last.par.best)$Cp
    }else{
        logCp <- get.par('logCp', rept)
        tac <- exp(qnorm(fractileCatch, logCp[2], logCp[4]))
    }
    if(!exp) tac <- log(tac)
    return(tac)
}


#' @name man.select
#' @title Select management scenarios
#'
#' @param rep A result report as generated by running \code{manage} or
#'     \code{add.man.scenario}.
#' @param scenarios Selection of scenarios in preferred order. Can be a vector
#'     with the names of the selected scenarios or numbers indicating their
#'     position in \code{rep$man}, e.g. \code{c(6,2)} for the 6th and 2nd
#'     scenario in the \code{rep$man} list. Setting this argument to \code{NULL}
#'     or "none", removes all scenarios from the spict object. By default
#'     (\code{'all'}), all scenarios are selected.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#'
#' @return A fitted spict object wit selected management scenarios in preferred
#'     order in \code{rep$man}.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- manage(rep, c(2,4,6))
#'
#' ## based on names
#' names(rep$man)
#' rep1 <- man.select(rep, c("curentF","noF"))
#'
#' ## based on indices
#' length(rep$man)
#' rep2 <- man.select(rep, c(1,3))
#'
#' @export
man.select <- function(rep, scenarios = "all", verbose = TRUE){
    ## checks
    if(!inherits(rep, "spictcls") || !"opt" %in% names(rep))
        stop("rep needs to be a fitted spict object!")
    if(!any(names(rep)=="man")) stop("Apply manage() first.")
    ## scenarios in index or name
    rep <- repVarPer
    scenariosAll <- names(rep$man)
    scenarios <- NULL
    if(all(is.numeric(scenarios))){
        ind <- scenarios %in% 1:length(scenariosAll)
        if(any(!ind) && verbose) cat("Scenario(s): ", scenarios[which(!ind)],
                                     " outside of range of possible scenarios (length(rep$man)): ",
                                     length(scenariosAll),"\n")
        scenarios <- scenariosAll[scenarios[ind]]
    }else if(!is.null(scenarios) && !is.na(scenarios) && scenarios[1] == "all"){
        scenarios <- scenariosAll
    }else if(is.null(scenarios) || is.na(scenarios)){
        scenarios <- "none"
    }
    scenarios <- as.character(scenarios)
    indscenarios <- which(scenariosAll %in% scenarios)
    if(verbose){
        if(length(indscenarios) == 0 && scenarios[1] != "none"){
            cat("No matching scenario found.\n")
        }else if(scenarios[1] != "none"){
            cat("Selected scenario(s): ",paste(scenariosAll[indscenarios], collapse = ", ")," \n")
        }else{
            cat("All scenarios removed! \n")
        }
    }

    ## select scenarios
    repout <- rep
    repout$man <- list()
    if(scenarios != "none"){
        repout$man <- rep$man[indscenarios]
    }else repout$man <- NULL

    ## return
    return(repout)
}


#' @name man.tac
#' @title Get the TAC for the management scenarios
#'
#' @param rep A result report as generated by running \code{manage} or
#'     \code{add.man.scenario}.
#' @param fractileCatch Fractile of predicted catch distribution. By default
#'     (0.5), the median is being used.
#' @param exp Should tac be reported on natural scale (default: TRUE).
#' @param verbose Should detailed outputs be provided (default: TRUE).
#'
#' @return rep wit selected management scenarios
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' rep <- manage(rep, c(3,4,5))
#'
#' ## Median of predicted catch distributions
#' man.tac(rep)
#'
#' ## 30th percentile of catch distributions
#' man.tac(rep, fractileCatch = 0.3)
#'
#' @export
man.tac <- function(rep, fractileCatch = 0.5, exp = TRUE, verbose=TRUE){
    check.rep(rep)
    if(!"man" %in% names(rep) && verbose) cat("No element called 'man' object in the 'rep' list. Run 'manage()' or 'add.man.scenario()' first!\n")

    ## function(x) x$obj$report(x$obj$env$last.par.best)$Cp
    tacs <- lapply(rep$man, calc.tac, fractileCatch = fractileCatch, exp = exp)

    return(tacs)
}



#' @name man.timeline
#' @title Print a schematic to the console visualising the management timeline
#'
#' @param x Either an input list from \code{check.inp} or a result report as
#'     generated by running \code{fit.spict}.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param obsonly Display observation period only
#'
#' @return Nothing
#'
#' @examples
#' data(pol)
#' inp <- check.inp(pol$albacore)
#' inp$maninterval <- c(1991,1992)
#' rep <- fit.spict(inp)
#'
#' ## based on an input list
#' man.timeline(inp)
#'
#' ## based on an output list
#' man.timeline(rep)
#'
#' @export
man.timeline <- function(x, verbose = TRUE, obsonly = FALSE){
    if(!inherits(x, "spictcls")){
        x <- try(check.inp(x, verbose = FALSE, mancheck = TRUE), silent=TRUE)
        if(inherits(x, "try-error")){
            stop("Provided object 'x' needs to be an input list or a fitted spict object!")
        }
    }
    if(inherits(x, "spictcls") && "opt" %in% names(x)){
        x <- check.man.time(x, printTimeline = FALSE)
        if(any(names(x) == "man")){
            obsobly <- !check.man(x, verbose=verbose)$mantime
            inp <- x$man[[1]]$inp
        }else{
            inp <- x$inp
        }
    }else{
        inp <- x
    }
    inp <- check.inp(inp, verbose = FALSE, mancheck = FALSE)
    timeC <- format(round(inp$timerangeObs,2),nsmall=2)
    timeM <- format(round(range(inp$maninterval),2),nsmall=2)
    timeInt <- format(c(max(timeC), min(timeM)),nsmall=2)
    obstext <- c("     Observations",
                 paste0("   ",min(timeC)," - ",max(timeC)),
                 "|-----------------------|")
    inttext <- c("    Intermediate  ",
                 paste0("  ",min(timeInt)," - ",max(timeInt)),
                 "----------------------|")
    mantext <- c("     Management ",
                 paste0("  ",min(timeM)," - ",max(timeM)),
                 "----------------------|")
    if(obsonly){
        df <- cbind(obstext)
    }else if(max(timeC) == min(timeM)){
        df <- cbind(obstext, mantext)
    }else{
        df <- cbind(obstext, inttext, mantext)
    }
    rownames(df) <- rep("",dim(df)[1])
    colnames(df) <- rep("",dim(df)[2])
    cat("SPiCT timeline:\n")
    print(df, quote=FALSE, row.names = FALSE)
    cat(paste0("\nManagement evaluation: ",inp$maneval,"\n"))
}


#' @name get.TAC
#' @title Calculate TAC based on specific HCR
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param scenarioTitle Title of scenario (default: \code{'customScenario_X'},
#'     where X corresponds to a numeric counting equal to the numer of scenarios
#'     with this name in \code{rep$man} plus 1, e.g. \code{'customScenario_3'}).
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: \code{maninterval = c(2020.25,2021.25)}.
#'     Default: NULL.
#' @param maneval Time at which to evaluate model states. Example: \code{maneval
#'     = 2021.25}. Default: NULL.
#' @param ffac Factor to multiply current fishing mortality by (default: 1).
#' @param cfac Factor to multiply current catch by (default: 1). Please refer to
#'     the details for more information.
#' @param csdfac Factor for the multiplication of the standard deviation of the
#'     catch (default: 1). Please refer to the details for more information.
#' @param fractiles List defining the fractiles of the 3 distributions of
#'     'catch', 'bbmsy', and 'ffmsy'. By default (0.5) median is used for all 3
#'     quantities. Please refer to the details for more information.
#' @param breakpointBBmsy Breakpoint in terms of \eqn{B/B_{MSY}} for the
#'     hockey-stick HCR. By default (0) no breakpoint is assumed. Please refer
#'     to the details for more information.
#' @param safeguardB List defining an optional precautionary buffer by means of
#'     a biomass reference level relative to \eqn{B/B_{MSY}} (\code{'limitB'};
#'     default: 0, i.e. deactivating the PA buffer) and the risk aversion
#'     probability (\code{'prob'}; default: 0.95). Please refer to the details
#'     for more information.
#' @param intermediatePeriodCatch Catch during intermediate period, e.g. last
#'     year's TAC (default: \code{NULL}). Please refer to the details for more
#'     information.
#' @param intermediatePeriodCatchSDFac Factor for the multiplication of the
#'     standard deviation of the catch during the intermediate period (default:
#'     1). Please refer to the details for more information.
#' @param intermediatePeriodCatchList List defining catch in the intermediate
#'     period obtaining the elements 'obsC', 'timeC', and 'dtc' (optional
#'     element 'stdevfacC' which is 1 if not provided). Please refer to the
#'     details for more information.
#' @param catchList List obtaining the elements 'obsC', 'timeC', and 'dtc'
#'     (optional element 'stdevfacC' which is 1 if not provided). Please refer
#'     to the details for more information.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param dbg Debug flag, dbg=1 some output, dbg=2 more output.
#' @param checkman Should the time-dependent objects in \code{inp} be checked
#'     against the management time and corrected if necessary? (Default: TRUE)
#'
#' @details For detailed information, please refer to
#'     \code{\link{add.man.scenario}}.
#'
#' @return The total allowable catch based on specified HCR.
#'
#' @export
#' @examples
#' rep <- fit.spict(pol$albacore)
#'
#' ## Fishing at Fmsy
#' get.TAC(rep)
#'
#' ## MSY hockey-stick rule
#' get.TAC(rep, breakpointB = 0.5)
#'
#' ## ICES (2019) recommended HCR
#' get.TAC(rep, fractiles = list(catch=0.35, bbmsy=0.35, ffmsy=0.35), breakpointB=0.5)
#'
get.TAC <- function(rep,
                    scenarioTitle = "",
                    maninterval = NULL,
                    maneval = NULL,
                    ffac = NULL,   ## if NULL default fishing at fmsy
                    cfac = NULL,
                    csdfac = 1,
                    fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5),
                    breakpointB = 0,
                    safeguardB = list(limitB = 0, prob = 0.95),
                    intermediatePeriodCatch = NULL,
                    intermediatePeriodCatchSDFac = 1,
                    intermediatePeriodCatchList = NULL,
                    catchList = NULL,
                    verbose = TRUE,
                    dbg = 0,
                    mancheck = TRUE){

    check.rep(rep, reportmode0 = FALSE)
    ## check if management time within model time
    if((!is.null(maninterval) || !is.null(maneval)) && mancheck){
        repin <- check.man.time(rep, maninterval = maninterval, maneval = maneval, verbose = FALSE)
    }else repin <- rep

    ## FRACTILES
    if(!is.list(fractiles)) stop("Please provide 'fractiles' with the arguments: 'catch', 'bbmsy', and 'ffmsy'!")
    default_fractiles = list(catch = 0.5, bbmsy = 0.5, ffmsy = 0.5)
    fList <- default_fractiles[which(!names(default_fractiles) %in% names(fractiles))]
    fList <- c(fList,fractiles)

    ## get updated inp
    inpt <- make.man.inp(rep=repin,
                         scenarioTitle = scenarioTitle,
                         maninterval = maninterval,
                         maneval = maneval,
                         ffac = ffac,
                         cfac = cfac,
                         csdfac = csdfac,
                         fractiles = fractiles,
                         breakpointB = breakpointB,
                         safeguardB = safeguardB,
                         intermediatePeriodCatch = intermediatePeriodCatch,
                         intermediatePeriodCatchSDFac = intermediatePeriodCatchSDFac,
                         intermediatePeriodCatchList = intermediatePeriodCatchList,
                         catchList = catchList,
                         verbose = verbose,
                         dbg = dbg,
                         mancheck = FALSE)

    ## return tac only
    tac <- try(calc.tac(rep=repin, inp=inpt, fractileCatch=fList$catch), silent=TRUE)
    if(is(tac,"try-error")) stop("TAC could not be estimated.")
    return(tac)
}



#' @name check.man
#' @title Check the consistency of management scenarios in rep
#'
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param maninterval Two floats representing the start and end of the
#'     management period. Example: maninterval = c(2020.25,2021.25). Default:
#'     NULL.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#'
#' @details Internal function that checks if the fitted spict objects in
#'     \code{rep$man} have a consistent management interval.
#'
#' @return TRUE/FALSE
#'
check.man <- function(rep, maninterval = NULL, verbose = TRUE){
    ## rep wrong class
    check.rep(rep)
    if(!is.null(maninterval) && length(maninterval) != 2 && all(is.numeric(maninterval)))
        stop("The argument 'maninterval' has to be comprised of two numeric values!")

    ## management in rep
    manInRep <- "man" %in% names(rep)
    if(!manInRep && verbose) cat("No element called 'man' object in the 'rep' list. Run 'manage()' or 'add.man.scenario()' first!\n")

    ## maninterval & intermediate period
    if(manInRep){
        nsc <- length(rep$man)
        checkMantime <- matrix(FALSE,ncol=2,nrow=nsc)
        checkInter <- rep(FALSE,nsc)
        for(i in 1:nsc){
            rp <- rep$man[[i]]
            checkMantime[i,] <- rp$inp$maninterval
            ind <- which(rp$inp$timeCpred == min(rp$inp$maninterval)) - 1
            checkInter[i] <- round(get.par("logCpred", rp, exp=TRUE)[ind,2])
        }
        if(!is.null(maninterval)) checkMantime <- rbind(checkMantime, maninterval)
        checks1 <- apply(checkMantime,2,function(x) all(x[1] == x))
        if(!all(checks1) && verbose) cat("The management intervals differ between scenarios.\n")
        checks2 <- all(checkInter[1] == checkInter)
        if(!all(checks2) && verbose) cat("The assumptions about the intermediate period differ between scenarios, e.g. continuing the F process vs. constant catch during the intermediate period.\n")
    }

    ## return combined logical value
    reslist <- list(mantime = manInRep && all(checks1),
                    inter = manInRep && all(checks2))
    return(reslist)
}
